// Generated by LiveScript 1.5.0
var async, ref$, red, green, child_process, EventEmitter, fs, yaml, path, rimraf, ServiceCloner, flatten, AppCloner;
async = require('async');
ref$ = require('chalk'), red = ref$.red, green = ref$.green;
child_process = require('child_process');
EventEmitter = require('events').EventEmitter;
fs = require('fs');
yaml = require('js-yaml');
path = require('path');
rimraf = require('rimraf');
ServiceCloner = require('./service-cloner');
flatten = require('prelude-ls').flatten;
AppCloner = (function(superclass){
  var prototype = extend$((import$(AppCloner, superclass).displayName = 'AppCloner', AppCloner), superclass).prototype, constructor = AppCloner;
  function AppCloner(arg$){
    this.repository = arg$.repository, this.logger = arg$.logger;
    this._log = bind$(this, '_log', prototype);
  }
  AppCloner.prototype.start = function(){
    var this$ = this;
    if (this.gitCloneApp(process.cwd(), this.repository.origin)) {
      return this.logger.log({
        role: 'exo-clone',
        text: red("Error: cloning " + this.repository.name + " failed")
      });
    }
    this.logger.log({
      role: 'exo-clone\'',
      text: this.repository.name + " Application cloned into " + this.repository.path
    });
    return this.verifyIsExoApp(function(err){
      var configPath, cloners, res$, protectionLevel, lresult$, serviceRole, ref$, serviceData, serviceDir, serviceOrigin, cloner;
      switch (false) {
      case !err:
        return this$.logger.log({
          role: 'exo-clone',
          text: red("Error: application could not be verified.\n " + err)
        });
      }
      configPath = path.join(this$.repository.path, 'application.yml');
      this$.appConfig = yaml.safeLoad(fs.readFileSync(configPath, 'utf8'));
      this$.logger.setColors(Object.keys(this$.appConfig.services));
      res$ = [];
      for (protectionLevel in this$.appConfig.services) {
        lresult$ = [];
        for (serviceRole in ref$ = this$.appConfig.services[protectionLevel]) {
          serviceData = ref$[serviceRole];
          serviceDir = path.join(this$.repository.path, serviceData.local);
          serviceOrigin = serviceData.origin;
          lresult$.push(new ServiceCloner({
            role: serviceRole,
            config: {
              root: this$.repository.path,
              path: serviceDir,
              origin: serviceOrigin
            },
            logger: this$.logger
          }));
        }
        res$.push(lresult$);
      }
      cloners = res$;
      return async.series((function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = flatten(cloners)).length; i$ < len$; ++i$) {
          cloner = ref$[i$];
          if (cloner.config.origin) {
            results$.push(cloner.start);
          }
        }
        return results$;
      }()), function(err, exitCodes){
        switch (false) {
        case !(err || this$._containsNonZero(exitCodes)):
          this$.logger.log({
            role: 'exo-clone',
            text: red("Some services failed to clone or were invalid Exosphere services.\nFailed")
          });
          break;
        default:
          this$.logger.log({
            role: 'exo-clone',
            text: green("All services successfully cloned.\nDone")
          });
        }
        if (err || this$._containsNonZero(exitCodes)) {
          return this$.removeDir(this$.repository.path);
        }
      });
    });
  };
  AppCloner.prototype._log = function(text){
    return this.logger.log({
      role: 'exo-clone',
      text: text,
      trim: true
    });
  };
  AppCloner.prototype._containsNonZero = function(exitCodes){
    var this$ = this;
    return exitCodes.filter((function(it){
      return it > 0;
    })).length > 0;
  };
  AppCloner.prototype.gitCloneApp = function(cwd, origin){
    var output;
    output = child_process.spawnSync("git", ("clone " + origin).split(' '), {
      cwd: cwd,
      stdio: [1, 2]
    });
    switch (output.status) {
    case 0:
      this._log(output.stderr.toString().trim());
      break;
    default:
      this._log(red(output.stderr.toString().trim()));
    }
    return output.status;
  };
  AppCloner.prototype.removeDir = function(dirPath){
    return rimraf(dirPath, function(error){
      switch (false) {
      case !error:
        return this._log("Could not remove " + dirPath);
      }
    });
  };
  AppCloner.prototype.verifyIsExoApp = function(callback){
    var err;
    try {
      return fs.accessSync(path.join(this.repository.path, 'application.yml'));
    } catch (e$) {
      err = e$;
      return this.removeDir(this.repository.path);
    } finally {
      callback(err);
    }
  };
  return AppCloner;
}(EventEmitter));
module.exports = AppCloner;
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}