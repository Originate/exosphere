{"version":3,"sources":["reroute.js"],"names":[],"mappings":";;;;;;;;;;;;;;AASA,IAAM,MAAM,GAAI,OAAO,CAAC,QAAQ,CAAC,CAAC;AAClC,IAAM,GAAG,GAAO,OAAO,CAAC,KAAK,CAAC,CAAC;;;;;;AAO/B,IAAM,OAAO,GAAG,UAAS,CAAC;;;;AAI1B,IAAM,OAAO,GAAG,KAAK,CAAC;;;;;;;;;;;AAYtB,SAAS,cAAc;;;4BAAiB;QAAhB,QAAQ;QAAE,IAAI;;;AACpC,QAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AACpC,QAAI,KAAK,EACP,OAAO,KAAK,CAAC,IAAI,CAAC,CAAC;;;;AAIrB,QAAM,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,qBAAqB,EAAE,IAAI,CAAC,CAAC;AAC/D,QAAI,QAAQ,KAAK,IAAI;WACG,QAAQ;YAAE,IAAI;;AARhC,WAAK,GAML,QAAQ;;KAE0B;GACzC;CAAA;;;AAID,SAAS,eAAe,GAAG;AACzB,MAAI,OAAO,EACT,OAAO;AACT,SAAO,GAAG,IAAI,CAAC;;AAEf,MAAM,OAAO,GAAG,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC;AAC7C,KAAG,CAAC,MAAM,CAAC,SAAS,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE,QAAQ,EAAE;AACzD,QAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;AAC/B,UAAM,IAAI,GAAG,cAAc,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;AACxD,UAAI,IAAI,EAAE;AACR,eAAO,GAAG,eAAc,EAAE,EAAE,OAAO,EAAE,EAAE,IAAI,EAAE,WAAW,EAAE,IAAI,EAAJ,IAAI,EAAE,CAAC,CAAC;AAClE,eAAO,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;OAC9C;KACF;AACD,WAAO,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;GACvC,CAAC;CACH;;;;AAKD,MAAM,CAAC,OAAO,GAAG,SAAS,QAAQ,CAAC,MAAM,EAAE,MAAM,EAAE;AACjD,QAAM,CAAC,MAAM,EAAE,gEAAgE,CAAC,CAAC;AACjF,MAAM,UAAU,GAAM,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,MAAM,UAAU,GAAM,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AACjD,MAAM,KAAK,GAAW,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;AACpD,SAAO,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;AAC/B,MAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EACpB,KAAK,CAAC,UAAU,CAAC,GAAG,MAAM,CAAC;AAC7B,QAAM,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,MAAM,iCACC,MAAM,YAAO,KAAK,CAAC,UAAU,CAAC,CAAG,CAAC;;;AAGtE,iBAAe,EAAE,CAAC;CACnB,CAAC","file":"reroute.js","sourcesContent":["// Domain routing and port forwarding\n//\n// Used for mapping hosts and domains to localhost, so you can open TCP\n// connections with friendly hostnames to test against the local server.\n//\n// Can also map any source port to any destination port, so you can use port 80\n// to access localhost server running on unprivileged port.\n\n\nconst assert  = require('assert');\nconst Net     = require('net');\n\n\n// Routing table.\n//\n// key   - Source host name or wildcard (e.g. \"example.com\", \"*.example.com\")\n// value - Object that maps source port to target port\nconst routing = new Map();\n\n// Flip this from enableRerouting() so we only inject our code into\n// Socket.connect once.\nlet   enabled = false;\n\n\n// If there's a route for host/port, returns destination port number.\n//\n// Called recursively to handle wildcards.  Starting with the host\n// www.example.com, it will attempt to match routes from most to least specific:\n//\n//   www.example.com\n// *.www.example.com\n//     *.example.com\n//             *.com\nfunction findTargetPort(hostname, port) {\n  const route = routing.get(hostname);\n  if (route)\n    return route[port];\n\n  // This will first expand www.hostname.com to *.www.hostname.com,\n  // then contract it to *.hostname.com, *.com and finally *.\n  const wildcard = hostname.replace(/^(\\*\\.[^.]+(\\.|$))?/, '*.');\n  if (wildcard !== '*.')\n    return findTargetPort(wildcard, port);\n}\n\n\n// Called once to hack Socket.connect\nfunction enableRerouting() {\n  if (enabled)\n    return;\n  enabled = true;\n\n  const connect = Net.Socket.prototype.connect;\n  Net.Socket.prototype.connect = function(options, callback) {\n    if (typeof options === 'object') {\n      const port = findTargetPort(options.host, options.port);\n      if (port) {\n        options = Object.assign({}, options, { host: 'localhost', port });\n        return connect.call(this, options, callback);\n      }\n    }\n    return connect.apply(this, arguments);\n  };\n}\n\n\n// source - Hostname or host:port (default to port 80)\n// target - Target port number\nmodule.exports = function addRoute(source, target) {\n  assert(source, 'Expected source address of the form \"host:port\" or just \"host\"');\n  const sourceHost    = source.split(':')[0];\n  const sourcePort    = source.split(':')[1] || 80;\n  const route         = routing.get(sourceHost) || {};\n  routing.set(sourceHost, route);\n  if (!route[sourcePort])\n    route[sourcePort] = target;\n  assert(route[sourcePort] === target,\n         `Already have routing from ${source} to ${route[sourcePort]}`);\n\n  // Enable Socket.connect routing\n  enableRerouting();\n};\n\n\n"]}