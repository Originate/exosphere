/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var abbrev, red, add, clone, create, deploy, lint, run, setup, sync, test, fs, map, pkg, path, updateNotifier, commands, commandName, fullCommandName;
	abbrev = __webpack_require__(2);
	red = __webpack_require__(3).red;
	add = __webpack_require__(4);
	clone = __webpack_require__(24);
	create = __webpack_require__(31);
	deploy = __webpack_require__(34);
	lint = __webpack_require__(37);
	run = __webpack_require__(39);
	setup = __webpack_require__(47);
	sync = __webpack_require__(54);
	test = __webpack_require__(57);
	fs = __webpack_require__(6);
	map = __webpack_require__(11).map;
	pkg = __webpack_require__(60);
	path = __webpack_require__(16);
	updateNotifier = __webpack_require__(61);
	updateNotifier({
	  pkg: pkg
	}).notify();
	commands = {
	  add: add,
	  clone: clone,
	  create: create,
	  deploy: deploy,
	  lint: lint,
	  run: run,
	  setup: setup,
	  sync: sync,
	  test: test
	};
	commandName = process.argv[2];
	fullCommandName = completeCommandName(commandName);
	if (commandName === 'version') {
	  console.log("Exosphere version " + pkg.version);
	} else if (!commandName) {
	  missingCommand();
	} else if (!fullCommandName) {
	  unknownCommand(commandName);
	} else {
	  process.argv.shift();
	  commands[fullCommandName]();
	}
	function completeCommandName(commandName){
	  return abbrev(commandNames())[commandName];
	}
	function missingCommand(){
	  console.log(red("Error: missing command\n"));
	  return printUsage();
	}
	function unknownCommand(command){
	  console.log(red("Error: unknown command '" + command + "'\n"));
	  return printUsage();
	}
	function printUsage(){
	  var i$, ref$, len$, command;
	  console.log('Usage: exo <command> [options]\n');
	  console.log('Available commands are:');
	  for (i$ = 0, len$ = (ref$ = commandNames()).length; i$ < len$; ++i$) {
	    command = ref$[i$];
	    if (command === 'add') {
	      console.log("* add [<service-name>] [<template-name>] [<model-name>] [<description>]");
	    } else {
	      console.log("* " + command);
	    }
	  }
	  return console.log();
	}
	function commandNames(){
	  return Object.keys(commands);
	}
	//# sourceMappingURL=/Users/originate/Desktop/MonoRepos/exosphere/cli/node_modules/livescript-loader/index.js!/Users/originate/Desktop/MonoRepos/exosphere/cli/src/cli.ls.map


/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("abbrev");

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("chalk");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var ref$, cyan, green, red, blue, inquirer, fs, glob, yaml, Logger, templatesPath, merge, N, path, tmplconv, yamlCutter;
	ref$ = __webpack_require__(3), cyan = ref$.cyan, green = ref$.green, red = ref$.red, blue = ref$.blue;
	inquirer = __webpack_require__(5);
	fs = __webpack_require__(6);
	glob = __webpack_require__(7);
	yaml = __webpack_require__(8);
	ref$ = __webpack_require__(9), Logger = ref$.Logger, templatesPath = ref$.templatesPath;
	merge = __webpack_require__(21);
	N = __webpack_require__(19);
	path = __webpack_require__(16);
	tmplconv = __webpack_require__(22);
	yamlCutter = __webpack_require__(23);
	module.exports = function(){
	  var ref$, data, questions, appConfig, e;
	  if (process.argv[2] === "help") {
	    help();
	    return;
	  }
	  console.log('We are about to add a new Exosphere service to the application!\n');
	  ref$ = parseCommandLine(process.argv), data = ref$.data, questions = ref$.questions;
	  try {
	    appConfig = yaml.safeLoad(fs.readFileSync('application.yml', 'utf8'));
	  } catch (e$) {
	    e = e$;
	    if (e.code === 'ENOENT') {
	      console.log(red("Error: application.yml not found. Please run this command in the root directory of an Exosphere application."));
	      process.exit();
	    }
	    throw e;
	  }
	  return inquirer.prompt(questions).then(function(answers){
	    var srcPath, targetPath;
	    data = merge(data, answers);
	    srcPath = path.join(templatesPath, 'add-service', data.templateName);
	    targetPath = path.join(process.cwd(), data.serviceName);
	    data.appName = appConfig.name;
	    return tmplconv.render(srcPath, targetPath, {
	      data: data
	    }).then(function(){
	      var options;
	      options = {
	        file: 'application.yml',
	        root: 'services.public',
	        key: data.serviceName,
	        value: {
	          location: "./" + data.serviceName
	        }
	      };
	      return yamlCutter.insertHash(options, N(function(){
	        return console.log(green("\ndone"));
	      }));
	    });
	  });
	};
	function serviceNames(){
	  return fs.readdirSync(path.join(templatesPath, 'add-service'));
	}
	function help(){
	  var helpMessage;
	  helpMessage = "\nUsage: " + cyan('exo-add') + " " + blue('[<entity-name>]') + "\n\nAdds a new service to the current application.\nThis command must be called in the root directory of the application.\n\noptions: " + blue('[<service-name>] [<template>] [<model>] [<description>]');
	  return console.log(helpMessage);
	}
	function parseCommandLine(commandLineArgs){
	  var data, questions, _, entityName, serviceName, author, templateName, modelName, description;
	  data = {};
	  questions = [];
	  _ = commandLineArgs[0], _ = commandLineArgs[1], entityName = commandLineArgs[2], serviceName = commandLineArgs[3], author = commandLineArgs[4], templateName = commandLineArgs[5], modelName = commandLineArgs[6], description = commandLineArgs[7];
	  if (serviceName) {
	    data.serviceName = serviceName;
	  } else {
	    questions.push({
	      message: 'Name of the service to create:',
	      type: 'input',
	      name: 'serviceName',
	      filter: function(input){
	        return input.trim();
	      },
	      validate: function(input){
	        return input.length > 0;
	      }
	    });
	  }
	  if (description) {
	    data.description = description;
	  } else {
	    questions.push({
	      message: 'Description:',
	      type: 'input',
	      name: 'description',
	      filter: function(input){
	        return input.trim();
	      }
	    });
	  }
	  if (author) {
	    data.author = author;
	  } else {
	    questions.push({
	      message: 'Author:',
	      type: 'input',
	      name: 'author',
	      filter: function(input){
	        return input.trim();
	      },
	      validator: function(input){
	        return input.length > 0;
	      }
	    });
	  }
	  if (templateName) {
	    data.templateName = templateName;
	  } else {
	    questions.push({
	      message: 'Type:',
	      type: 'list',
	      name: 'templateName',
	      choices: serviceNames()
	    });
	  }
	  if (modelName) {
	    data.modelName = modelName;
	  } else {
	    questions.push({
	      message: 'Name of the data model:',
	      type: 'input',
	      name: 'modelName',
	      filter: function(input){
	        return input.trim();
	      }
	    });
	  }
	  return {
	    data: data,
	    questions: questions
	  };
	}

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("inquirer");

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("glob");

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = require("js-yaml");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {// Generated by LiveScript 1.5.0
	var Logger, DockerHelper, callArgs, compileServiceMessages, normalizePath, killChildProcesses, path;
	Logger = __webpack_require__(10);
	DockerHelper = __webpack_require__(12);
	callArgs = __webpack_require__(14);
	compileServiceMessages = __webpack_require__(15);
	normalizePath = __webpack_require__(17);
	killChildProcesses = __webpack_require__(18);
	path = __webpack_require__(16);
	module.exports = {
	  callArgs: callArgs,
	  compileServiceMessages: compileServiceMessages,
	  Logger: Logger,
	  DockerHelper: DockerHelper,
	  exampleAppsPath: path.join(__dirname, '..', 'example-apps'),
	  normalizePath: normalizePath,
	  killChildProcesses: killChildProcesses,
	  templatesPath: path.join(__dirname, '..', 'templates')
	};
	/* WEBPACK VAR INJECTION */}.call(exports, "../exosphere-shared/dist"))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var ref$, black, blue, bold, cyan, dim, green, magenta, red, reset, white, yellow, map, maximum, Logger;
	ref$ = __webpack_require__(3), black = ref$.black, blue = ref$.blue, bold = ref$.bold, cyan = ref$.cyan, dim = ref$.dim, green = ref$.green, magenta = ref$.magenta, red = ref$.red, reset = ref$.reset, white = ref$.white, yellow = ref$.yellow;
	ref$ = __webpack_require__(11), map = ref$.map, maximum = ref$.maximum;
	Logger = (function(){
	  Logger.displayName = 'Logger';
	  var prototype = Logger.prototype, constructor = Logger;
	  function Logger(serviceNames){
	    serviceNames == null && (serviceNames = []);
	    this.error = bind$(this, 'error', prototype);
	    this.log = bind$(this, 'log', prototype);
	    this.colors = {
	      exocom: blue,
	      exorun: reset,
	      'exo-clone': reset,
	      'exo-setup': reset,
	      'exo-test': reset,
	      'exo-sync': reset,
	      'exo-lint': reset,
	      'exo-deploy': reset
	    };
	    this.setColors(serviceNames);
	  }
	  Logger.prototype.log = function(arg$){
	    var name, text, trim, color, ref$, i$, len$, line, results$ = [];
	    name = arg$.name, text = arg$.text, trim = arg$.trim;
	    color = (ref$ = this.colors[name]) != null ? ref$ : reset;
	    if (trim) {
	      text = text.trim();
	    }
	    for (i$ = 0, len$ = (ref$ = text.split('\n')).length; i$ < len$; ++i$) {
	      line = ref$[i$];
	      results$.push(console.log(color(bold(this._pad(name) + " ")), color(line)));
	    }
	    return results$;
	  };
	  Logger.prototype.error = function(arg$){
	    var name, text, trim, color, ref$, i$, len$, line, results$ = [];
	    name = arg$.name, text = arg$.text, trim = arg$.trim;
	    color = (ref$ = this.colors[name]) != null ? ref$ : reset;
	    if (trim) {
	      text = text.trim();
	    }
	    for (i$ = 0, len$ = (ref$ = text.split('\n')).length; i$ < len$; ++i$) {
	      line = ref$[i$];
	      results$.push(console.error(color(bold(this._pad(name) + " ")), red(line)));
	    }
	    return results$;
	  };
	  Logger.prototype.setColors = function(serviceNames){
	    var i$, len$, i, serviceName, this$ = this;
	    for (i$ = 0, len$ = serviceNames.length; i$ < len$; ++i$) {
	      i = i$;
	      serviceName = serviceNames[i$];
	      this.colors[serviceName] = Logger._default_colors[i % Logger._default_colors.length];
	    }
	    return this.length = maximum(
	    map(function(it){
	      return it.length;
	    }, Object.keys(this.colors)));
	  };
	  Logger._default_colors = [blue, cyan, magenta, yellow];
	  Logger.prototype._pad = function(text){
	    return ("               " + text).slice(-this.length);
	  };
	  return Logger;
	}());
	module.exports = Logger;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = require("prelude-ls");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var child_process, DockerHelper;
	child_process = __webpack_require__(13);
	DockerHelper = (function(){
	  DockerHelper.displayName = 'DockerHelper';
	  var prototype = DockerHelper.prototype, constructor = DockerHelper;
	  DockerHelper.containerExists = function(container){
	    var this$ = this;
	    return function(it){
	      return it.includes(container);
	    }(
	    child_process.execSync('docker ps -a --format {{.Names}}', 'utf8'));
	  };
	  DockerHelper.getBuildCommand = function(image, buildFlags){
	    return "docker build -t " + image.author + "/" + image.name + " " + (buildFlags ? buildFlags : "") + " .";
	  };
	  DockerHelper.getDockerIp = function(container){
	    if (this.containerExists(container)) {
	      return child_process.execSync("docker inspect --format '{{ .NetworkSettings.IPAddress }}' " + container, "utf8");
	    }
	  };
	  DockerHelper.getDockerImages = function(){
	    return child_process.execSync('docker images');
	  };
	  DockerHelper.getPullCommand = function(image){
	    return "docker pull " + image.author + "/" + image.name + (image.version ? ":" + image.version : "");
	  };
	  DockerHelper.removeContainer = function(container){
	    if (this.containerExists(container)) {
	      return child_process.execSync("docker rm -f " + container);
	    }
	  };
	  DockerHelper.imageExists = function(image){
	    var this$ = this;
	    return function(it){
	      return it.includes(image.author + "/" + image.name);
	    }(
	    child_process.execSync("docker images " + image.author + "/" + image.name + (image.version ? ":" + image.version : ""), "utf-8"));
	  };
	  function DockerHelper(){}
	  return DockerHelper;
	}());
	module.exports = DockerHelper;

/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = require("child_process");

/***/ },
/* 14 */
/***/ function(module, exports) {

	// Generated by LiveScript 1.5.0
	var callArgs;
	callArgs = function(command){
	  switch (false) {
	  case process.platform !== 'win32':
	    return ['cmd', '/c', command.replace(/\//g, '\\')];
	  default:
	    return ['bash', '-c', command.replace(/\\/g, '/')];
	  }
	};
	module.exports = callArgs;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var path, fs, yaml;
	path = __webpack_require__(16);
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	module.exports = function(appConfig, basePath){
	  var serviceMessages, type, serviceName, ref$, serviceData, serviceConfig;
	  serviceMessages = [];
	  for (type in appConfig.services) {
	    for (serviceName in ref$ = appConfig.services[type + ""]) {
	      serviceData = ref$[serviceName];
	      serviceConfig = yaml.safeLoad(fs.readFileSync(path.join(basePath != null
	        ? basePath
	        : process.cwd(), serviceData.location, 'service.yml'), 'utf8'));
	      serviceMessages.push({
	        name: serviceName,
	        receives: serviceConfig.messages.receives,
	        sends: serviceConfig.messages.sends,
	        namespace: serviceData.namespace
	      });
	    }
	  }
	  return serviceMessages;
	};

/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 17 */
/***/ function(module, exports) {

	// Generated by LiveScript 1.5.0
	var normalizePath;
	normalizePath = function(filePath){
	  switch (false) {
	  case process.platform !== 'win32':
	    return filePath.replace(/\//g, '\\');
	  default:
	    return filePath.replace(/\\/g, '/');
	  }
	};
	module.exports = normalizePath;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var N, psTree;
	N = __webpack_require__(19);
	psTree = __webpack_require__(20);
	module.exports = function(done){
	  var this$ = this;
	  return psTree(process.pid, N(function(children){
	    var i$, len$, child;
	    for (i$ = 0, len$ = children.length; i$ < len$; ++i$) {
	      child = children[i$];
	      try {
	        process.kill(child.PID);
	      } catch (e$) {}
	    }
	    return done();
	  }));
	};

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = require("nitroglycerin");

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = require("ps-tree");

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = require("merge");

/***/ },
/* 22 */
/***/ function(module, exports) {

	module.exports = require("tmplconv");

/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = require("yaml-cutter");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var AppCloner, ref$, cyan, green, red, yellow, yaml, Logger, path, flatten, clone;
	AppCloner = __webpack_require__(25);
	ref$ = __webpack_require__(3), cyan = ref$.cyan, green = ref$.green, red = ref$.red, yellow = ref$.yellow;
	yaml = __webpack_require__(8);
	Logger = __webpack_require__(9).Logger;
	path = __webpack_require__(16);
	flatten = __webpack_require__(11).flatten;
	clone = function(){
	  var ref$, _, repoOrigin, repo, logger, x$;
	  console.log('We are going to clone an Exosphere application!\n');
	  ref$ = process.argv, _ = ref$[0], _ = ref$[1], repoOrigin = ref$[2];
	  if (!repoOrigin) {
	    return missingOrigin();
	  }
	  repo = repoInfo(repoOrigin);
	  logger = new Logger;
	  x$ = new AppCloner(repo);
	  x$.on('output', function(data){
	    return logger.log(data);
	  });
	  x$.on('app-config-ready', function(appConfig){
	    return logger.setColors(Object.keys(appConfig.services));
	  });
	  x$.on('app-verification-failed', function(err){
	    return logger.log({
	      name: 'exo-clone',
	      text: red("Error: application could not be verified.\n" + red(err))
	    });
	  });
	  x$.on('app-clone-success', function(){
	    return logger.log({
	      name: 'exo-clone',
	      text: repo.name + " Application cloned into " + repo.path
	    });
	  });
	  x$.on('app-clone-failed', function(){
	    return logger.log({
	      name: 'exo-clone',
	      text: red("Error: cloning " + repo.name + " failed")
	    });
	  });
	  x$.on('service-clone-fail', function(name){
	    return logger.log({
	      name: name,
	      text: red("Service cloning failed")
	    });
	  });
	  x$.on('service-invalid', function(name){
	    return logger.log({
	      name: name,
	      text: red(name + " is an invalid service")
	    });
	  });
	  x$.on('service-clones-failed', function(){
	    return logger.log({
	      name: 'exo-clone',
	      text: red("Some services failed to clone or were invalid Exosphere services.\nFailed")
	    });
	  });
	  x$.on('all-clones-successful', function(){
	    return logger.log({
	      name: 'exo-clone',
	      text: green("Services successfully cloned.\nDone")
	    });
	  });
	  x$.on('done', function(){
	    return logger.log({
	      name: 'exo-clone',
	      text: 'Done'
	    });
	  });
	  x$.start();
	  return x$;
	};
	function repoInfo(origin){
	  var repoName, repoPath, repo;
	  repoName = path.basename(origin, '.git');
	  repoPath = path.join(process.cwd(), repoName);
	  return repo = {
	    name: repoName,
	    origin: origin,
	    path: repoPath
	  };
	}
	function missingOrigin(){
	  console.log(red("Error: missing repository origin"));
	  return printUsage();
	}
	function printUsage(){
	  return console.log('Usage: exo clone <origin>\n');
	}
	module.exports = clone;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var async, red, child_process, EventEmitter, fs, yaml, path, rimraf, ServiceCloner, flatten, AppCloner;
	async = __webpack_require__(26);
	red = __webpack_require__(3).red;
	child_process = __webpack_require__(13);
	EventEmitter = __webpack_require__(27).EventEmitter;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	path = __webpack_require__(16);
	rimraf = __webpack_require__(28);
	ServiceCloner = __webpack_require__(29);
	flatten = __webpack_require__(11).flatten;
	AppCloner = (function(superclass){
	  var prototype = extend$((import$(AppCloner, superclass).displayName = 'AppCloner', AppCloner), superclass).prototype, constructor = AppCloner;
	  function AppCloner(repository){
	    this.repository = repository;
	    this._log = bind$(this, '_log', prototype);
	  }
	  AppCloner.prototype.start = function(){
	    var this$ = this;
	    if (this.gitCloneApp(process.cwd(), this.repository.origin)) {
	      return this.emit('app-clone-failed');
	    }
	    this.emit('app-clone-success');
	    return this.verifyIsExoApp(function(err){
	      var configPath, cloners, res$, type, lresult$, serviceName, ref$, serviceData, serviceDir, serviceOrigin, x$, cloner;
	      switch (false) {
	      case !err:
	        return this$.emit('app-verification-failed', err);
	      }
	      configPath = path.join(this$.repository.path, 'application.yml');
	      this$.appConfig = yaml.safeLoad(fs.readFileSync(configPath, 'utf8'));
	      this$.emit('app-config-ready', this$.appConfig);
	      res$ = [];
	      for (type in this$.appConfig.services) {
	        lresult$ = [];
	        for (serviceName in ref$ = this$.appConfig.services[type]) {
	          serviceData = ref$[serviceName];
	          serviceDir = path.join(this$.repository.path, serviceData.local);
	          serviceOrigin = serviceData.origin;
	          x$ = new ServiceCloner(serviceName, {
	            root: this$.repository.path,
	            path: serviceDir,
	            origin: serviceOrigin
	          });
	          x$.on('service-clone-success', fn$);
	          x$.on('service-clone-fail', fn1$);
	          x$.on('service-invalid', fn2$);
	          x$.on('output', fn3$);
	          lresult$.push(x$);
	        }
	        res$.push(lresult$);
	      }
	      cloners = res$;
	      return async.series((function(){
	        var i$, ref$, len$, results$ = [];
	        for (i$ = 0, len$ = (ref$ = flatten(cloners)).length; i$ < len$; ++i$) {
	          cloner = ref$[i$];
	          if (cloner.config.origin) {
	            results$.push(cloner.start);
	          }
	        }
	        return results$;
	      }()), function(err, exitCodes){
	        switch (false) {
	        case !err:
	          this$.emit('service-clones-failed');
	          break;
	        case !this$._containsNonZero(exitCodes):
	          this$.emit('service-clones-failed');
	          break;
	        default:
	          this$.emit('all-clones-successful');
	        }
	        if (err || this$._containsNonZero(exitCodes)) {
	          return this$.removeDir(this$.repository.path);
	        }
	      });
	      function fn$(name){
	        return this$.emit('service-clone-success', name);
	      }
	      function fn1$(name){
	        return this$.emit('service-clone-fail', name);
	      }
	      function fn2$(name){
	        return this$.emit('service-invalid', name);
	      }
	      function fn3$(data){
	        return this$.emit('output', data);
	      }
	    });
	  };
	  AppCloner.prototype._log = function(text){
	    return this.emit('output', {
	      name: 'exo-clone',
	      text: text,
	      trim: true
	    });
	  };
	  AppCloner.prototype._containsNonZero = function(exitCodes){
	    var this$ = this;
	    return exitCodes.filter((function(it){
	      return it > 0;
	    })).length > 0;
	  };
	  AppCloner.prototype.gitCloneApp = function(cwd, origin){
	    var output;
	    output = child_process.spawnSync("git", ("clone " + origin).split(' '), {
	      cwd: cwd,
	      stdio: [1, 2]
	    });
	    switch (output.status) {
	    case 0:
	      this._log(output.stderr.toString().trim());
	      break;
	    default:
	      this._log(red(output.stderr.toString().trim()));
	    }
	    return output.status;
	  };
	  AppCloner.prototype.removeDir = function(dirPath){
	    return rimraf(dirPath, function(error){
	      switch (false) {
	      case !error:
	        return this._log("Could not remove " + dirPath);
	      }
	    });
	  };
	  AppCloner.prototype.verifyIsExoApp = function(callback){
	    var err;
	    try {
	      return fs.accessSync(path.join(this.repository.path, 'application.yml'));
	    } catch (e$) {
	      err = e$;
	      return this.removeDir(this.repository.path);
	    } finally {
	      callback(err);
	    }
	  };
	  return AppCloner;
	}(EventEmitter));
	module.exports = AppCloner;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = require("async");

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = require("events");

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = require("rimraf");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var EventEmitter, fs, ObservableProcess, path, ServiceCloner;
	EventEmitter = __webpack_require__(27);
	fs = __webpack_require__(6);
	ObservableProcess = __webpack_require__(30);
	path = __webpack_require__(16);
	ServiceCloner = (function(superclass){
	  var prototype = extend$((import$(ServiceCloner, superclass).displayName = 'ServiceCloner', ServiceCloner), superclass).prototype, constructor = ServiceCloner;
	  function ServiceCloner(name, config){
	    this.name = name;
	    this.config = config;
	    this.write = bind$(this, 'write', prototype);
	    this.start = bind$(this, 'start', prototype);
	  }
	  ServiceCloner.prototype.start = function(done){
	    var x$, this$ = this;
	    x$ = new ObservableProcess(this._createCommand('git clone'), {
	      cwd: this.config.root,
	      stdout: {
	        write: this.write
	      },
	      stderr: {
	        write: this.write
	      }
	    });
	    x$.on('ended', function(exitCode){
	      switch (false) {
	      case !(exitCode > 0):
	        this$.emit('service-clone-fail', this$.name);
	        break;
	      case !!this$._isValidService():
	        this$.emit('service-invalid', this$.name);
	        exitCode = 1;
	        break;
	      default:
	        this$.emit('service-clone-success', this$.name);
	      }
	      return done(null, exitCode);
	    });
	    return x$;
	  };
	  ServiceCloner.prototype._isValidService = function(){
	    var e;
	    try {
	      fs.accessSync(path.join(this.config.path, 'service.yml'));
	      return true;
	    } catch (e$) {
	      e = e$;
	      return false;
	    }
	  };
	  ServiceCloner.prototype._createCommand = function(command){
	    return [command, this.config.origin, this.config.path].join(' ');
	  };
	  ServiceCloner.prototype.write = function(text){
	    return this.emit('output', {
	      name: this.name,
	      text: text.trim().replace(/\.*$/, '')
	    });
	  };
	  return ServiceCloner;
	}(EventEmitter));
	module.exports = ServiceCloner;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = require("observable-process");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var abbrev, application, red, fs, path, map, service, entities;
	abbrev = __webpack_require__(2);
	application = __webpack_require__(32);
	red = __webpack_require__(3).red;
	fs = __webpack_require__(6);
	path = __webpack_require__(16);
	map = __webpack_require__(11).map;
	service = __webpack_require__(33);
	entities = {
	  application: application,
	  service: service
	};
	module.exports = function(){
	  var entityName, fullEntityName;
	  entityName = process.argv[2];
	  if (!entityName) {
	    return missingEntity();
	  }
	  fullEntityName = abbrev(entityNames())[entityName];
	  if (!in$(fullEntityName, entityNames())) {
	    return unknownCommand(entityName);
	  }
	  return entities[fullEntityName]();
	};
	function missingEntity(){
	  console.log(red("Error: missing entity for 'create' command\n"));
	  return printUsage();
	}
	function unknownCommand(entity){
	  console.log(red("Error: cannot create '" + entity + "'\n"));
	  return printUsage();
	}
	function printUsage(){
	  var i$, ref$, len$, entity;
	  console.log('Usage: exo create [<entity>] [<name>] [<template>] [<model>] [<description>]\n');
	  console.log('Available entities are:');
	  for (i$ = 0, len$ = (ref$ = entityNames()).length; i$ < len$; ++i$) {
	    entity = ref$[i$];
	    console.log("* " + entity);
	  }
	  return console.log();
	}
	function entityNames(){
	  return Object.keys(entities);
	}
	function in$(x, xs){
	  var i = -1, l = xs.length >>> 0;
	  while (++i < l) if (x === xs[i]) return true;
	  return false;
	}

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var green, templatesPath, inquirer, merge, path, empty, tmplconv, application, slice$ = [].slice;
	green = __webpack_require__(3).green;
	templatesPath = __webpack_require__(9).templatesPath;
	inquirer = __webpack_require__(5);
	merge = __webpack_require__(21);
	path = __webpack_require__(16);
	empty = __webpack_require__(11).empty;
	tmplconv = __webpack_require__(22);
	application = function(){
	  var ref$, data, questions;
	  console.log('We are about to create a new Exosphere application');
	  ref$ = parseCommandLine(process.argv), data = ref$.data, questions = ref$.questions;
	  return inquirer.prompt(questions).then(function(answers){
	    var srcPath, targetPath;
	    data = merge(data, answers);
	    srcPath = path.join(templatesPath, 'create-app');
	    targetPath = data['app-name'];
	    console.log();
	    return tmplconv.render(srcPath, targetPath, {
	      data: data
	    }).then(function(){
	      return console.log(green("\ndone"));
	    });
	  });
	};
	function parseCommandLine(commandLineArgs){
	  var data, questions, _, appName, appVersion, appDescription;
	  data = {};
	  questions = [];
	  _ = commandLineArgs[0], _ = commandLineArgs[1], _ = commandLineArgs[2], appName = commandLineArgs[3], appVersion = commandLineArgs[4], appDescription = slice$.call(commandLineArgs, 5);
	  if (appName) {
	    data['app-name'] = appName;
	  } else {
	    questions.push({
	      type: 'input',
	      name: 'app-name',
	      message: 'Name of the application to create:',
	      filter: function(input){
	        return input.trim();
	      },
	      validate: function(input){
	        return input.length > 0;
	      }
	    });
	  }
	  if (!empty(appDescription)) {
	    data['app-description'] = appDescription.join(' ');
	  } else {
	    questions.push({
	      type: 'input',
	      name: 'app-description',
	      message: 'Description:'
	    });
	  }
	  if (appVersion) {
	    data['app-version'] = appVersion;
	  } else {
	    questions.push({
	      type: 'input',
	      name: 'app-version',
	      message: 'Initial version:',
	      'default': '0.0.1'
	    });
	  }
	  return {
	    data: data,
	    questions: questions
	  };
	}
	module.exports = application;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var green, templatesPath, inquirer, fs, yaml, merge, N, path, empty, tmplconv, yamlCutter, service, slice$ = [].slice;
	green = __webpack_require__(3).green;
	templatesPath = __webpack_require__(9).templatesPath;
	inquirer = __webpack_require__(5);
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	merge = __webpack_require__(21);
	N = __webpack_require__(19);
	path = __webpack_require__(16);
	empty = __webpack_require__(11).empty;
	tmplconv = __webpack_require__(22);
	yamlCutter = __webpack_require__(23);
	service = function(){
	  var ref$, data, questions;
	  console.log('We are about to create a new Exosphere service!\n');
	  ref$ = parseCommandLine(process.argv), data = ref$.data, questions = ref$.questions;
	  return inquirer.prompt(questions).then(function(answers){
	    var srcPath, targetPath, appConfig, error;
	    data = merge(data, answers);
	    srcPath = path.join(templatesPath, 'add-service', data.templateName);
	    targetPath = path.join(process.cwd(), '..', data.serviceName);
	    try {
	      appConfig = yaml.safeLoad(fs.readFileSync('application.yml', 'utf8'));
	    } catch (e$) {
	      error = e$;
	      throw new Error("Creation of service '" + data.serviceName + "' has failed.");
	    }
	    data.appName = appConfig.name;
	    return tmplconv.render(srcPath, targetPath, {
	      data: data
	    }).then(function(){
	      var options;
	      options = {
	        file: 'application.yml',
	        root: 'services.public',
	        key: data.serviceName,
	        value: {
	          location: "../" + data.serviceName
	        }
	      };
	      return yamlCutter.insertHash(options, N(function(){
	        return console.log(green("\ndone"));
	      }));
	    });
	  });
	};
	function serviceNames(){
	  return fs.readdirSync(path.join(templatesPath, 'add-service'));
	}
	function parseCommandLine(commandLineArgs){
	  var data, questions, _, serviceName, author, templateName, modelName, description;
	  data = {};
	  questions = [];
	  _ = commandLineArgs[0], _ = commandLineArgs[1], _ = commandLineArgs[2], serviceName = commandLineArgs[3], author = commandLineArgs[4], templateName = commandLineArgs[5], modelName = commandLineArgs[6], description = slice$.call(commandLineArgs, 7);
	  if (serviceName) {
	    data.serviceName = serviceName;
	  } else {
	    questions.push({
	      message: 'Name of the service to create',
	      type: 'input',
	      name: 'serviceName',
	      filter: function(input){
	        return input.trim();
	      },
	      validate: function(input){
	        return input.length > 0;
	      }
	    });
	  }
	  if (templateName) {
	    data.templateName = templateName;
	  } else {
	    questions.push({
	      message: 'Type:',
	      type: 'list',
	      name: 'templateName',
	      choices: serviceNames()
	    });
	  }
	  if (modelName) {
	    data.modelName = modelName;
	  } else {
	    questions.push({
	      message: 'Name of the data model (leave blank if no model exists):',
	      type: 'input',
	      name: 'modelName',
	      filter: function(input){
	        return input.trim();
	      }
	    });
	  }
	  if (!empty(description)) {
	    data.description = description.join(' ');
	  } else {
	    questions.push({
	      message: 'Description:',
	      type: 'input',
	      name: 'description',
	      filter: function(input){
	        return input.trim();
	      }
	    });
	  }
	  if (author) {
	    data.author = author;
	  } else {
	    questions.push({
	      message: 'Author:',
	      type: 'input',
	      name: 'author',
	      filter: function(input){
	        return input.trim();
	      },
	      validator: function(input){
	        return input.length > 0;
	      }
	    });
	  }
	  return {
	    data: data,
	    questions: questions
	  };
	}
	module.exports = service;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var ref$, cyan, green, Docker, Logger, fs, yaml, path;
	ref$ = __webpack_require__(3), cyan = ref$.cyan, green = ref$.green;
	Docker = __webpack_require__(35);
	Logger = __webpack_require__(9).Logger;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	path = __webpack_require__(16);
	module.exports = function(){
	  var appConfig, logger, x$, this$ = this;
	  appConfig = yaml.safeLoad(fs.readFileSync(path.join(process.cwd(), 'application.yml'), 'utf8'));
	  console.log("Deploying " + green(appConfig.name) + " " + cyan(appConfig.version) + "\n");
	  logger = new Logger;
	  x$ = new Docker(appConfig, logger);
	  x$.dockerhubPush(function(err){
	    switch (false) {
	    case !err:
	      return logger.log({
	        name: 'exo-deploy',
	        text: err.message
	      });
	    }
	    return x$.start();
	  });
	  return x$;
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {// Generated by LiveScript 1.5.0
	var DockerHub, DockerHelper, fs, yaml, ObservableProcess, path, Docker;
	DockerHub = __webpack_require__(36);
	DockerHelper = __webpack_require__(9).DockerHelper;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	ObservableProcess = __webpack_require__(30);
	path = __webpack_require__(16);
	Docker = (function(){
	  Docker.displayName = 'Docker';
	  var prototype = Docker.prototype, constructor = Docker;
	  function Docker(appConfig, logger){
	    var this$ = this;
	    this.appConfig = appConfig;
	    this.logger = logger;
	    this.write = bind$(this, 'write', prototype);
	    this._run = bind$(this, '_run', prototype);
	    process.env.AWS_ACCESS_KEY_ID == null && (function(){
	      throw new Error("AWS_ACCESS_KEY_ID not provided");
	    }());
	    process.env.AWS_SECRET_ACCESS_KEY == null && (function(){
	      throw new Error("AWS_SECRET_ACCESS_KEY not provided");
	    }());
	    this.version = function(it){
	      return it.version;
	    }(
	    yaml.safeLoad(fs.readFileSync(path.join(__dirname, '../../package.json'), 'utf8')));
	  }
	  Docker.prototype.dockerhubPush = function(done){
	    var x$;
	    x$ = new DockerHub(this.appConfig, this.logger);
	    x$.push(function(err){
	      return done(err);
	    });
	    return x$;
	  };
	  Docker.prototype.start = function(){
	    var image, x$, this$ = this;
	    image = {
	      author: 'originate',
	      name: 'exo-deploy',
	      version: this.version
	    };
	    if (DockerHelper.imageExists(image)) {
	      return this._run();
	    } else {
	      this.logger.log({
	        name: 'exo-deploy',
	        text: "pulling ExoDeploy image version " + this.version
	      });
	      x$ = new ObservableProcess(DockerHelper.getPullCommand(image, {
	        stdout: {
	          write: this.write
	        },
	        stderr: {
	          write: this.write
	        }
	      }));
	      x$.on('ended', function(exitCode){
	        switch (false) {
	        case !exitCode:
	          return new Error("docker image originate/exo-deploy could not be pulled");
	        }
	        return this$._run();
	      });
	      return x$;
	    }
	  };
	  Docker.prototype._run = function(){
	    var flags, x$, this$ = this;
	    flags = ("-v " + process.cwd() + ":/var/app:ro ") + ("--env AWS_ACCESS_KEY_ID=" + process.env.AWS_ACCESS_KEY_ID + " ") + ("--env AWS_SECRET_ACCESS_KEY=" + process.env.AWS_SECRET_ACCESS_KEY + " ");
	    x$ = new ObservableProcess("docker run " + flags + " originate/exo-deploy:" + this.version, {
	      stdout: {
	        write: this.write
	      },
	      stderr: {
	        write: this.write
	      }
	    });
	    x$.on('ended', function(exitCode){
	      switch (false) {
	      case !exitCode:
	        return new Error("docker image originate/exo-deploy could not be run");
	      }
	    });
	    return x$;
	  };
	  Docker.prototype.write = function(text){
	    return this.logger.log({
	      name: 'exo-deploy',
	      text: text,
	      trim: false
	    });
	  };
	  return Docker;
	}());
	module.exports = Docker;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, "../exo-deploy/dist/docker"))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var async, child_process, DockerHelper, fs, yaml, ObservableProcess, path, DockerHub;
	async = __webpack_require__(26);
	child_process = __webpack_require__(13);
	DockerHelper = __webpack_require__(9).DockerHelper;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	ObservableProcess = __webpack_require__(30);
	path = __webpack_require__(16);
	DockerHub = (function(){
	  DockerHub.displayName = 'DockerHub';
	  var prototype = DockerHub.prototype, constructor = DockerHub;
	  function DockerHub(appConfig, logger){
	    this.appConfig = appConfig;
	    this.logger = logger;
	    this.write = bind$(this, 'write', prototype);
	    this._pushImage = bind$(this, '_pushImage', prototype);
	  }
	  DockerHub.prototype.push = function(done){
	    var images, i$, len$, image, this$ = this;
	    images = this._imageNames();
	    for (i$ = 0, len$ = images.length; i$ < len$; ++i$) {
	      image = images[i$];
	      if (!DockerHelper.imageExists(image)) {
	        return done(new Error("No Docker image exists for service '" + image.name + "'. Please run exo-setup."));
	      }
	    }
	    return async.eachSeries(images, function(){
	      return this$._pushImage(arguments[0], arguments[1]);
	    }, done);
	  };
	  DockerHub.prototype._pushImage = function(image, done){
	    var x$, this$ = this;
	    this.logger.log({
	      name: 'exo-deploy',
	      text: "pushing " + image.name + " to DockerHub..."
	    });
	    x$ = new ObservableProcess("docker push " + image.author + "/" + image.name, {
	      stdout: {
	        write: this.write
	      },
	      stderr: {
	        write: this.write
	      }
	    });
	    x$.on('ended', function(exitCode){
	      switch (false) {
	      case !exitCode:
	        return done(new Error(image.name + " could not be pushed to DockerHub"));
	      }
	      this$.logger.log({
	        name: 'exo-deploy',
	        text: image.name + " pushed to DockerHub"
	      });
	      return done();
	    });
	    return x$;
	  };
	  DockerHub.prototype._imageNames = function(){
	    var names, serviceType, name, ref$, config, serviceConfig;
	    names = [];
	    for (serviceType in this.appConfig.services) {
	      for (name in ref$ = this.appConfig.services[serviceType]) {
	        config = ref$[name];
	        serviceConfig = yaml.safeLoad(fs.readFileSync(path.join(process.cwd(), config.location, 'service.yml'), 'utf8'));
	        names.push({
	          author: serviceConfig.author,
	          name: path.basename(config.location)
	        });
	      }
	    }
	    return names;
	  };
	  DockerHub.prototype.write = function(text){
	    return this.logger.log({
	      name: 'exo-deploy',
	      text: text,
	      trim: false
	    });
	  };
	  return DockerHub;
	}());
	module.exports = DockerHub;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var AppLinter, ref$, cyan, dim, green, red, yaml, Logger, fs;
	AppLinter = __webpack_require__(38);
	ref$ = __webpack_require__(3), cyan = ref$.cyan, dim = ref$.dim, green = ref$.green, red = ref$.red;
	yaml = __webpack_require__(8);
	Logger = __webpack_require__(9).Logger;
	fs = __webpack_require__(6);
	module.exports = function(){
	  var appConfig, logger, x$, appLinter;
	  appConfig = yaml.safeLoad(fs.readFileSync('application.yml', 'utf8'));
	  console.log("Running linter for " + cyan(appConfig.name) + "\n");
	  logger = new Logger(Object.keys(appConfig.services));
	  x$ = appLinter = new AppLinter(appConfig);
	  x$.on('lint-success', function(){
	    return logger.log({
	      name: 'exo-lint',
	      text: 'Lint passed'
	    });
	  });
	  x$.on('output', function(data){
	    return logger.log(data);
	  });
	  x$.on('reset-colors', function(serviceNames){
	    return logger.setColors(serviceNames);
	  });
	  x$.start();
	  return x$;
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var async, EventEmitter, fs, path, ref$, difference, find, filter, reject, each, yaml, AppLinter;
	async = __webpack_require__(26);
	EventEmitter = __webpack_require__(27).EventEmitter;
	fs = __webpack_require__(6);
	path = __webpack_require__(16);
	ref$ = __webpack_require__(11), difference = ref$.difference, find = ref$.find, filter = ref$.filter, reject = ref$.reject, each = ref$.each;
	yaml = __webpack_require__(8);
	AppLinter = (function(superclass){
	  var prototype = extend$((import$(AppLinter, superclass).displayName = 'AppLinter', AppLinter), superclass).prototype, constructor = AppLinter;
	  function AppLinter(appConfig){
	    this.appConfig = appConfig;
	  }
	  AppLinter.prototype.start = function(){
	    var ref$, sentMessages, receivedMessages;
	    ref$ = this.aggregateMessages(), sentMessages = ref$.sentMessages, receivedMessages = ref$.receivedMessages;
	    this.emit('reset-colors', Object.keys(this.appConfig.services));
	    return this.lintMessages(sentMessages, receivedMessages);
	  };
	  AppLinter.prototype.lintMessages = function(sent, received){
	    var notReceived, notSent, i$, len$, msg, results$ = [];
	    notReceived = difference(Object.keys(sent), Object.keys(received));
	    notSent = difference(Object.keys(received), Object.keys(sent));
	    if (notReceived.length === 0 && notSent.length === 0) {
	      return this.emit('lint-success');
	    }
	    if (notReceived.length) {
	      this.emit('output', {
	        name: 'exo lint',
	        text: "The following messages are sent but not received:"
	      });
	      for (i$ = 0, len$ = notReceived.length; i$ < len$; ++i$) {
	        msg = notReceived[i$];
	        this.emit('output', {
	          name: sent[msg],
	          text: msg
	        });
	      }
	    }
	    if (notSent.length) {
	      this.emit('output', {
	        name: 'exo lint',
	        text: "The following messages are received but not sent:"
	      });
	      for (i$ = 0, len$ = notSent.length; i$ < len$; ++i$) {
	        msg = notSent[i$];
	        results$.push(this.emit('output', {
	          name: received[msg],
	          text: msg
	        }));
	      }
	      return results$;
	    }
	  };
	  AppLinter.prototype.aggregateMessages = function(){
	    var sentMessages, receivedMessages, serviceName, serviceConfig, i$, ref$, len$, message;
	    sentMessages = {};
	    receivedMessages = {};
	    for (serviceName in this.appConfig.services) {
	      serviceConfig = this.getConfig(serviceName);
	      for (i$ = 0, len$ = (ref$ = serviceConfig.messages.sends || []).length; i$ < len$; ++i$) {
	        message = ref$[i$];
	        (sentMessages[message] || (sentMessages[message] = [])).push(serviceName);
	      }
	      for (i$ = 0, len$ = (ref$ = serviceConfig.messages.receives || []).length; i$ < len$; ++i$) {
	        message = ref$[i$];
	        (receivedMessages[message] || (receivedMessages[message] = [])).push(serviceName);
	      }
	    }
	    return {
	      sentMessages: sentMessages,
	      receivedMessages: receivedMessages
	    };
	  };
	  AppLinter.prototype.getConfig = function(serviceName){
	    var serviceRoot;
	    serviceRoot = path.join(process.cwd(), this.appConfig.services[serviceName].location);
	    return yaml.safeLoad(fs.readFileSync(path.join(serviceRoot, 'service.yml'), 'utf8'));
	  };
	  return AppLinter;
	}(EventEmitter));
	module.exports = AppLinter;
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var AppRunner, ref$, bold, cyan, dim, green, red, fs, yaml, Logger, flatten, util;
	AppRunner = __webpack_require__(40);
	ref$ = __webpack_require__(3), bold = ref$.bold, cyan = ref$.cyan, dim = ref$.dim, green = ref$.green, red = ref$.red;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	Logger = __webpack_require__(9).Logger;
	flatten = __webpack_require__(11).flatten;
	util = __webpack_require__(46);
	module.exports = function(){
	  var appConfig, logger, type, x$, appRunner, this$ = this;
	  if (process.argv[2] === "help") {
	    help();
	    return;
	  }
	  appConfig = yaml.safeLoad(fs.readFileSync('application.yml', 'utf8'));
	  console.log("Running " + green(appConfig.name) + " " + cyan(appConfig.version) + "\n");
	  logger = new Logger(flatten((function(){
	    var results$ = [];
	    for (type in appConfig.services) {
	      results$.push(Object.keys(appConfig.services[type]));
	    }
	    return results$;
	  }())));
	  x$ = appRunner = new AppRunner({
	    appConfig: appConfig,
	    logger: logger
	  });
	  x$.on('routing-setup', function(){
	    var command, ref$, routing, text, receivers, res$, i$, ref1$, len$, receiver, results$ = [];
	    logger.log({
	      name: 'exocom',
	      text: 'received routing setup'
	    });
	    for (command in ref$ = appRunner.exocom.clientRegistry.routes) {
	      routing = ref$[command];
	      text = "  [ " + bold(command) + " ]  -->  ";
	      res$ = [];
	      for (i$ = 0, len$ = (ref1$ = routing.receivers).length; i$ < len$; ++i$) {
	        receiver = ref1$[i$];
	        res$.push(bold(receiver.name) + " (" + receiver.host + ":" + receiver.port + ")");
	      }
	      receivers = res$;
	      text += receivers.join(' & ');
	      results$.push(logger.log({
	        name: 'exocom',
	        text: text
	      }));
	    }
	    return results$;
	  });
	  x$.on('message', function(arg$){
	    var messages, receivers, message, indent, i$, ref$, len$, line, results$ = [];
	    messages = arg$.messages, receivers = arg$.receivers;
	    message = messages[0];
	    if (message.name !== message.originalName) {
	      logger.log({
	        name: 'exocom',
	        text: bold(message.sender) + "  --[ " + bold(message.originalName) + " ]-[ " + bold(message.name) + " ]->  " + bold(receivers.join(' and '))
	      });
	    } else {
	      logger.log({
	        name: 'exocom',
	        text: bold(message.sender) + "  --[ " + bold(message.name) + " ]->  " + bold(receivers.join(' and '))
	      });
	    }
	    indent = repeatString$(' ', message.sender.length + 2);
	    if (message.payload != null) {
	      for (i$ = 0, len$ = (ref$ = util.inspect(message.payload, {
	        showHidden: false,
	        depth: null
	      }).split('\n')).length; i$ < len$; ++i$) {
	        line = ref$[i$];
	        results$.push(logger.log({
	          name: 'exocom',
	          text: indent + "" + dim(line),
	          trim: false
	        }));
	      }
	      return results$;
	    } else {
	      return logger.log({
	        name: 'exocom',
	        text: indent + "" + dim('(no payload)'),
	        trim: false
	      });
	    }
	  });
	  x$.startExocom();
	  x$.startServices();
	  return process.on('SIGINT', function(){
	    return appRunner.shutdown({
	      closeMessage: " shutting down ..."
	    });
	  });
	};
	function help(){
	  var helpMessage;
	  console.log("\nUsage: " + cyan('exo-run\n'));
	  helpMessage = "Runs an Exosphere application.\n\nMust be executed in the application directory.";
	  return console.log(helpMessage);
	}
	function repeatString$(str, n){
	  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
	  return r;
	}

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var async, red, child_process, DockerRunner, EventEmitter, ref$, compileServiceMessages, DockerHelper, N, portReservation, path, ServiceRunner, waitUntil, AppRunner;
	async = __webpack_require__(26);
	red = __webpack_require__(3).red;
	child_process = __webpack_require__(13);
	DockerRunner = __webpack_require__(41);
	EventEmitter = __webpack_require__(27).EventEmitter;
	ref$ = __webpack_require__(9), compileServiceMessages = ref$.compileServiceMessages, DockerHelper = ref$.DockerHelper;
	N = __webpack_require__(19);
	portReservation = __webpack_require__(42);
	path = __webpack_require__(16);
	ServiceRunner = __webpack_require__(44);
	waitUntil = __webpack_require__(43).waitUntil;
	AppRunner = (function(superclass){
	  var prototype = extend$((import$(AppRunner, superclass).displayName = 'AppRunner', AppRunner), superclass).prototype, constructor = AppRunner;
	  function AppRunner(arg$){
	    this.appConfig = arg$.appConfig, this.logger = arg$.logger;
	    this.shutdown = bind$(this, 'shutdown', prototype);
	  }
	  AppRunner.prototype.startExocom = function(done){
	    var x$, this$ = this;
	    x$ = portReservation;
	    x$.getPort(N(function(exocomPort){
	      var serviceMessages, x$;
	      this$.exocomPort = exocomPort;
	      serviceMessages = function(it){
	        return it.replace(/"/g, '');
	      }(
	      JSON.stringify(
	      compileServiceMessages(this$.appConfig)));
	      this$.dockerConfig = {
	        author: 'originate',
	        image: 'exocom',
	        startCommand: 'bin/exocom',
	        env: {
	          SERVICE_MESSAGES: serviceMessages,
	          PORT: this$.exocomPort,
	          SERVICE_NAME: 'exocom'
	        },
	        publish: {
	          EXOCOM_PORT: this$.exocomPort + ":" + this$.exocomPort
	        }
	      };
	      x$ = this$.exocom = new DockerRunner({
	        name: 'exocom',
	        dockerConfig: this$.dockerConfig,
	        logger: this$.logger
	      });
	      x$.startService();
	      x$.on('error', function(message){
	        return this$.shutdown({
	          errorMessage: message
	        });
	      });
	      return x$;
	    }));
	    return x$;
	  };
	  AppRunner.prototype.startServices = function(){
	    var this$ = this;
	    return waitUntil(function(){
	      return this$.exocomPort;
	    }, 1, function(){
	      var serviceType, serviceName, ref$, serviceData, i$, len$, service, x$, _, runner;
	      this$.services = [];
	      for (serviceType in this$.appConfig.services) {
	        for (serviceName in ref$ = this$.appConfig.services[serviceType]) {
	          serviceData = ref$[serviceName];
	          this$.services.push({
	            name: serviceName,
	            location: serviceData.location
	          });
	        }
	      }
	      this$.runners = {};
	      for (i$ = 0, len$ = (ref$ = this$.services).length; i$ < len$; ++i$) {
	        service = ref$[i$];
	        x$ = this$.runners[service.name] = new ServiceRunner({
	          name: service.name,
	          config: {
	            root: path.join(process.cwd(), service.location),
	            EXOCOM_PORT: this$.exocomPort
	          },
	          logger: this$.logger
	        });
	        x$.on('error', this$.shutdown);
	      }
	      return async.parallel((function(){
	        var ref$, results$ = [];
	        for (_ in ref$ = this.runners) {
	          runner = ref$[_];
	          results$.push(runner.start);
	        }
	        return results$;
	      }.call(this$)), function(err){
	        return this$.logger.log({
	          name: 'exo-run',
	          text: 'all services online'
	        });
	      });
	    });
	  };
	  AppRunner.prototype.shutdown = function(arg$){
	    var closeMessage, errorMessage, exitCode, i$, ref$, len$, service;
	    closeMessage = arg$.closeMessage, errorMessage = arg$.errorMessage;
	    switch (false) {
	    case !errorMessage:
	      console.log(red(errorMessage));
	      exitCode = 1;
	      break;
	    default:
	      console.log("\n\n " + closeMessage);
	      exitCode = 0;
	    }
	    DockerHelper.removeContainer('exocom');
	    for (i$ = 0, len$ = (ref$ = this.services).length; i$ < len$; ++i$) {
	      service = ref$[i$];
	      DockerHelper.removeContainer(service.name);
	    }
	    return process.exit(exitCode);
	  };
	  return AppRunner;
	}(EventEmitter));
	module.exports = AppRunner;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var red, child_process, EventEmitter, DockerHelper, fs, yaml, N, ObservableProcess, path, portReservation, last, waitUntil, DockerRunner;
	red = __webpack_require__(3).red;
	child_process = __webpack_require__(13);
	EventEmitter = __webpack_require__(27).EventEmitter;
	DockerHelper = __webpack_require__(9).DockerHelper;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	N = __webpack_require__(19);
	ObservableProcess = __webpack_require__(30);
	path = __webpack_require__(16);
	portReservation = __webpack_require__(42);
	last = __webpack_require__(11).last;
	waitUntil = __webpack_require__(43).waitUntil;
	DockerRunner = (function(superclass){
	  var prototype = extend$((import$(DockerRunner, superclass).displayName = 'DockerRunner', DockerRunner), superclass).prototype, constructor = DockerRunner;
	  function DockerRunner(arg$){
	    this.name = arg$.name, this.dockerConfig = arg$.dockerConfig, this.logger = arg$.logger;
	    this._runContainer = bind$(this, '_runContainer', prototype);
	    this._onContainerError = bind$(this, '_onContainerError', prototype);
	    this.write = bind$(this, 'write', prototype);
	  }
	  DockerRunner.prototype.startService = function(){
	    var this$ = this;
	    if (!DockerHelper.imageExists({
	      author: this.dockerConfig.author,
	      name: this.dockerConfig.image
	    })) {
	      return this.emit('error', "No Docker image exists for service '" + this.name + "'. Please run exo-setup.");
	    }
	    DockerHelper.removeContainer(this.name);
	    switch (this.name) {
	    case 'exocom':
	      return this._runContainer();
	    default:
	      return waitUntil(function(){
	        return DockerHelper.getDockerIp('exocom');
	      }, 10, function(){
	        this$.dockerConfig.env.EXOCOM_HOST = DockerHelper.getDockerIp('exocom');
	        return this$._runContainer();
	      });
	    }
	  };
	  DockerRunner.prototype.write = function(text){
	    return this.logger.log({
	      name: this.name,
	      text: text,
	      trim: true
	    });
	  };
	  DockerRunner.prototype._createRunCommand = function(){
	    var command, name, ref$, val, port, link, container;
	    command = "docker run --name=" + this.dockerConfig.env.SERVICE_NAME + " ";
	    for (name in ref$ = this.dockerConfig.env) {
	      val = ref$[name];
	      command += " -e " + name + "=" + val;
	    }
	    for (name in ref$ = this.dockerConfig.publish) {
	      port = ref$[name];
	      command += " --publish " + port;
	    }
	    for (link in ref$ = this.dockerConfig.link) {
	      container = ref$[link];
	      command += " --link " + container;
	    }
	    return command += " " + this.dockerConfig.author + "/" + this.dockerConfig.image + " " + this.dockerConfig.startCommand;
	  };
	  DockerRunner.prototype._onContainerError = function(){
	    return this.emit('error', "Service '" + this.name + "' crashed, shutting down application");
	  };
	  DockerRunner.prototype._runContainer = function(){
	    var x$, this$ = this;
	    x$ = this.dockerContainer = new ObservableProcess(this._createRunCommand(), {
	      stdout: {
	        write: this.write
	      },
	      stderr: {
	        write: this.write
	      }
	    });
	    x$.on('ended', function(exitCode, killed){
	      switch (false) {
	      case !(exitCode > 0 && !killed):
	        return this$._onContainerError();
	      }
	    });
	    x$.wait(this.dockerConfig.startText, function(){
	      this$.logger.log({
	        name: 'exo-run',
	        text: "'" + this$.name + "' is running"
	      });
	      return this$.emit('online');
	    });
	    return x$;
	  };
	  return DockerRunner;
	}(EventEmitter));
	module.exports = DockerRunner;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 42 */
/***/ function(module, exports) {

	module.exports = require("port-reservation");

/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = require("wait");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var child_process, watch, DockerRunner, EventEmitter, ref$, callArgs, DockerHelper, fs, yaml, N, ObservableProcess, path, portReservation, last, ServiceRunner;
	child_process = __webpack_require__(13);
	watch = __webpack_require__(45).watch;
	DockerRunner = __webpack_require__(41);
	EventEmitter = __webpack_require__(27).EventEmitter;
	ref$ = __webpack_require__(9), callArgs = ref$.callArgs, DockerHelper = ref$.DockerHelper;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	N = __webpack_require__(19);
	ObservableProcess = __webpack_require__(30);
	path = __webpack_require__(16);
	portReservation = __webpack_require__(42);
	last = __webpack_require__(11).last;
	ServiceRunner = (function(superclass){
	  var prototype = extend$((import$(ServiceRunner, superclass).displayName = 'ServiceRunner', ServiceRunner), superclass).prototype, constructor = ServiceRunner;
	  function ServiceRunner(arg$){
	    this.name = arg$.name, this.config = arg$.config, this.logger = arg$.logger;
	    this.write = bind$(this, 'write', prototype);
	    this.start = bind$(this, 'start', prototype);
	    this.serviceConfig = yaml.safeLoad(fs.readFileSync(path.join(this.config.root, 'service.yml'), 'utf8'));
	  }
	  ServiceRunner.prototype.start = function(done){
	    var x$, y$, this$ = this;
	    this.dockerConfig = {
	      author: this.serviceConfig.author,
	      image: path.basename(this.config.root),
	      startCommand: this.serviceConfig.startup.command,
	      startText: this.serviceConfig.startup['online-text'],
	      cwd: this.config.root,
	      env: {
	        EXOCOM_PORT: this.config.EXOCOM_PORT,
	        SERVICE_NAME: this.name
	      },
	      publish: this.serviceConfig.docker ? this.serviceConfig.docker.publish : void 8,
	      link: this.serviceConfig.docker ? this.serviceConfig.docker.link : void 8
	    };
	    x$ = this.dockerRunner = new DockerRunner({
	      name: this.name,
	      dockerConfig: this.dockerConfig,
	      logger: this.logger
	    });
	    x$.startService();
	    x$.on('online', function(){
	      return typeof done == 'function' ? done() : void 8;
	    });
	    x$.on('error', function(message){
	      return this$.emit('error', {
	        errorMessage: message
	      });
	    });
	    y$ = this.watcher = watch(this.config.root, {
	      ignoreInitial: true,
	      ignored: /.*\/node_modules\/.*/
	    });
	    y$.on('add', function(addedPath){
	      this$.logger.log({
	        name: 'exo-run',
	        text: "Restarting service '" + this$.name + "' because " + addedPath + " was created"
	      });
	      return this$.restart();
	    });
	    y$.on('change', function(changedPath){
	      this$.logger.log({
	        name: 'exo-run',
	        text: "Restarting service '" + this$.name + "' because " + changedPath + " was changed"
	      });
	      return this$.restart();
	    });
	    y$.on('unlink', function(removedPath){
	      this$.logger.log({
	        name: 'exo-run',
	        text: "Restarting service '" + this$.name + "' because " + removedPath + " was deleted"
	      });
	      return this$.restart();
	    });
	    return y$;
	  };
	  ServiceRunner.prototype.restart = function(){
	    var x$, this$ = this;
	    this.dockerRunner.dockerContainer.kill();
	    this.watcher.close();
	    x$ = new ObservableProcess(callArgs(DockerHelper.getBuildCommand({
	      author: this.dockerConfig.author,
	      name: this.dockerConfig.image
	    })), {
	      cwd: this.config.root,
	      stdout: {
	        write: this.write
	      },
	      stderr: {
	        write: this.write
	      }
	    });
	    x$.on('ended', function(exitCode, killed){
	      switch (false) {
	      case exitCode !== 0:
	        this$.logger.log({
	          name: this$.name,
	          text: "Docker image rebuilt"
	        });
	        return this$.start(function(){
	          return this$.logger.log({
	            name: 'exo-run',
	            text: "'" + this$.name + "' restarted successfully"
	          });
	        });
	      default:
	        this$.logger.log({
	          name: this$.name,
	          text: "Docker image failed to rebuild"
	        });
	        return process.exit(exitCode);
	      }
	    });
	    return x$;
	  };
	  ServiceRunner.prototype.write = function(text){
	    return this.logger.log({
	      name: this.name,
	      text: text,
	      trim: true
	    });
	  };
	  return ServiceRunner;
	}(EventEmitter));
	module.exports = ServiceRunner;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 45 */
/***/ function(module, exports) {

	module.exports = require("chokidar");

/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var AppSetup, ref$, cyan, green, yaml, Logger, fs, flatten;
	AppSetup = __webpack_require__(48);
	ref$ = __webpack_require__(3), cyan = ref$.cyan, green = ref$.green;
	yaml = __webpack_require__(8);
	Logger = __webpack_require__(9).Logger;
	fs = __webpack_require__(6);
	flatten = __webpack_require__(11).flatten;
	module.exports = function(){
	  var appConfig, logger, type, x$, appSetup;
	  appConfig = yaml.safeLoad(fs.readFileSync('application.yml', 'utf8'));
	  console.log("Setting up " + green(appConfig.name) + " " + cyan(appConfig.version) + "\n");
	  logger = new Logger(flatten((function(){
	    var results$ = [];
	    for (type in appConfig.services) {
	      results$.push(Object.keys(appConfig.services[type]));
	    }
	    return results$;
	  }())));
	  x$ = appSetup = new AppSetup({
	    appConfig: appConfig,
	    logger: logger
	  });
	  x$.on('output', function(data){
	    data.text = data.text.replace('\n', '');
	    return logger.log(data);
	  });
	  x$.startSetup();
	  return x$;
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var async, DockerSetup, EventEmitter, ExocomSetup, path, ServiceSetup, AppSetup;
	async = __webpack_require__(26);
	DockerSetup = __webpack_require__(49);
	EventEmitter = __webpack_require__(27).EventEmitter;
	ExocomSetup = __webpack_require__(52);
	path = __webpack_require__(16);
	ServiceSetup = __webpack_require__(53);
	AppSetup = (function(superclass){
	  var prototype = extend$((import$(AppSetup, superclass).displayName = 'AppSetup', AppSetup), superclass).prototype, constructor = AppSetup;
	  function AppSetup(arg$){
	    this.appConfig = arg$.appConfig, this.logger = arg$.logger;
	  }
	  AppSetup.prototype.startSetup = function(){
	    var serviceType, serviceName, ref$, serviceData, setups, res$, i$, len$, service, x$, dockerSetups, y$, operation, z$, this$ = this;
	    this.services = [];
	    for (serviceType in this.appConfig.services) {
	      for (serviceName in ref$ = this.appConfig.services[serviceType]) {
	        serviceData = ref$[serviceName];
	        this.services.push({
	          name: serviceName,
	          location: serviceData.location
	        });
	      }
	    }
	    res$ = [];
	    for (i$ = 0, len$ = (ref$ = this.services).length; i$ < len$; ++i$) {
	      service = ref$[i$];
	      x$ = new ServiceSetup({
	        name: service.name,
	        logger: this.logger,
	        config: {
	          root: path.join(process.cwd(), service.location)
	        }
	      });
	      x$.on('output', fn$);
	      res$.push(x$);
	    }
	    setups = res$;
	    res$ = [];
	    for (i$ = 0, len$ = (ref$ = this.services).length; i$ < len$; ++i$) {
	      service = ref$[i$];
	      y$ = new DockerSetup({
	        name: service.name,
	        logger: this.logger,
	        config: {
	          root: path.join(process.cwd(), service.location)
	        }
	      });
	      y$.on('output', fn1$);
	      res$.push(y$);
	    }
	    dockerSetups = res$;
	    operation = process.platform === 'win32'
	      ? async.mapSeries
	      : async.map;
	    operation(setups, function(){
	      return arguments[0].start(arguments[1]);
	    }, function(err){
	      return operation(dockerSetups, function(){
	        return arguments[0].start(arguments[1]);
	      }, function(err){
	        return this$.logger.log({
	          name: 'exo-setup',
	          text: 'setup complete'
	        });
	      });
	    });
	    z$ = new ExocomSetup(this.logger);
	    z$.start();
	    return z$;
	    function fn$(data){
	      return this$.emit('output', data);
	    }
	    function fn1$(data){
	      return this$.emit('output', data);
	    }
	  };
	  return AppSetup;
	}(EventEmitter));
	module.exports = AppSetup;
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var red, EventEmitter, ref$, templatesPath, callArgs, DockerHelper, fs, yaml, ObservableProcess, path, last, requireYaml, cp, DockerSetup;
	red = __webpack_require__(3).red;
	EventEmitter = __webpack_require__(27).EventEmitter;
	ref$ = __webpack_require__(9), templatesPath = ref$.templatesPath, callArgs = ref$.callArgs, DockerHelper = ref$.DockerHelper;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	ObservableProcess = __webpack_require__(30);
	path = __webpack_require__(16);
	last = __webpack_require__(11).last;
	requireYaml = __webpack_require__(50);
	cp = __webpack_require__(51).cp;
	DockerSetup = (function(superclass){
	  var prototype = extend$((import$(DockerSetup, superclass).displayName = 'DockerSetup', DockerSetup), superclass).prototype, constructor = DockerSetup;
	  function DockerSetup(arg$){
	    this.name = arg$.name, this.logger = arg$.logger, this.config = arg$.config;
	    this.write = bind$(this, 'write', prototype);
	    this._dockerFileExists = bind$(this, '_dockerFileExists', prototype);
	    this._buildDockerImage = bind$(this, '_buildDockerImage', prototype);
	    this.start = bind$(this, 'start', prototype);
	    this.serviceConfig = this.config ? yaml.safeLoad(fs.readFileSync(path.join(this.config.root, 'service.yml'), 'utf8')) : void 8;
	  }
	  DockerSetup.prototype.start = function(done){
	    switch (false) {
	    case !!this._dockerFileExists():
	      cp(path.join(templatesPath, 'docker', 'Dockerfile'), path.join(this.config.root, 'Dockerfile'));
	    }
	    this.logger.log({
	      name: this.name,
	      text: "preparing Docker image"
	    });
	    return this._buildDockerImage(done);
	  };
	  DockerSetup.prototype._buildDockerImage = function(done){
	    var serviceName, x$, this$ = this;
	    serviceName = last(
	    this.config.root.split(path.sep));
	    x$ = new ObservableProcess(callArgs(DockerHelper.getBuildCommand({
	      author: this.serviceConfig.author,
	      name: serviceName
	    })), {
	      cwd: this.config.root,
	      stdout: {
	        write: this.write
	      },
	      stderr: {
	        write: this.write
	      }
	    });
	    x$.on('ended', function(exitCode, killed){
	      switch (false) {
	      case exitCode !== 0:
	        this$.logger.log({
	          name: this$.name,
	          text: "Docker setup finished"
	        });
	        break;
	      default:
	        this$.logger.log({
	          name: this$.name,
	          text: "Docker setup failed"
	        });
	        process.exit(exitCode);
	      }
	      return done();
	    });
	    return x$;
	  };
	  DockerSetup.prototype._dockerFileExists = function(){
	    var e;
	    try {
	      return fs.accessSync(path.join(this.config.root, 'Dockerfile'));
	    } catch (e$) {
	      e = e$;
	      return false;
	    }
	  };
	  DockerSetup.prototype.write = function(text){
	    return this.emit('output', {
	      name: this.name,
	      text: text,
	      trim: true
	    });
	  };
	  return DockerSetup;
	}(EventEmitter));
	module.exports = DockerSetup;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = require("require-yaml");

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = require("shelljs");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var child_process, EventEmitter, DockerHelper, ObservableProcess, ExocomSetup;
	child_process = __webpack_require__(13);
	EventEmitter = __webpack_require__(27).EventEmitter;
	DockerHelper = __webpack_require__(9).DockerHelper;
	ObservableProcess = __webpack_require__(30);
	ExocomSetup = (function(superclass){
	  var prototype = extend$((import$(ExocomSetup, superclass).displayName = 'ExocomSetup', ExocomSetup), superclass).prototype, constructor = ExocomSetup;
	  function ExocomSetup(logger){
	    this.logger = logger;
	    this.write = bind$(this, 'write', prototype);
	    this.start = bind$(this, 'start', prototype);
	    this.name = 'exocom';
	  }
	  ExocomSetup.prototype.start = function(){
	    var version, x$, this$ = this;
	    version = function(it){
	      return it.trim();
	    }(
	    function(it){
	      return it.toString();
	    }(
	    child_process.execSync('npm show exocom-dev version')));
	    if (DockerHelper.imageExists({
	      author: 'originate',
	      name: 'exocom',
	      version: version
	    })) {
	      this.logger.log({
	        name: this.name,
	        text: 'ExoCom image already up to date'
	      });
	      return;
	    }
	    this.logger.log({
	      name: this.name,
	      text: "Pulling ExoCom image version " + version
	    });
	    x$ = new ObservableProcess(DockerHelper.getPullCommand({
	      author: 'originate',
	      name: 'exocom',
	      version: version
	    }), {
	      stdout: {
	        write: this.write
	      },
	      stderr: {
	        write: this.write
	      }
	    });
	    x$.on('ended', function(exitCode){
	      switch (false) {
	      case exitCode !== 0:
	        return this$.logger.log({
	          name: this$.name,
	          text: "ExoCom image updated to version " + version
	        });
	      default:
	        return this$.logger.log({
	          name: this$.name,
	          text: "Failed to retrieve latest ExoCom image"
	        });
	      }
	    });
	    return x$;
	  };
	  ExocomSetup.prototype.write = function(text){
	    return this.emit('output', {
	      name: this.name,
	      text: text,
	      trim: true
	    });
	  };
	  return ExocomSetup;
	}(EventEmitter));
	module.exports = ExocomSetup;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var red, EventEmitter, ref$, callArgs, normalizePath, fs, yaml, ObservableProcess, path, ServiceSetup;
	red = __webpack_require__(3).red;
	EventEmitter = __webpack_require__(27).EventEmitter;
	ref$ = __webpack_require__(9), callArgs = ref$.callArgs, normalizePath = ref$.normalizePath;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	ObservableProcess = __webpack_require__(30);
	path = __webpack_require__(16);
	ServiceSetup = (function(superclass){
	  var prototype = extend$((import$(ServiceSetup, superclass).displayName = 'ServiceSetup', ServiceSetup), superclass).prototype, constructor = ServiceSetup;
	  function ServiceSetup(arg$){
	    this.name = arg$.name, this.logger = arg$.logger, this.config = arg$.config;
	    this.write = bind$(this, 'write', prototype);
	    this.start = bind$(this, 'start', prototype);
	    this.serviceConfig = yaml.safeLoad(fs.readFileSync(path.join(this.config.root, 'service.yml'), 'utf8'));
	  }
	  ServiceSetup.prototype.start = function(done){
	    var x$, this$ = this;
	    this.logger.log({
	      name: this.name,
	      text: "starting setup"
	    });
	    x$ = new ObservableProcess(callArgs(normalizePath(this.serviceConfig.setup)), {
	      cwd: this.config.root,
	      stdout: {
	        write: this.write
	      },
	      stderr: {
	        write: this.write
	      }
	    });
	    x$.on('ended', function(exitCode, killed){
	      switch (false) {
	      case exitCode !== 0:
	        this$.logger.log({
	          name: this$.name,
	          text: 'setup finished'
	        });
	        break;
	      default:
	        this$.logger.log({
	          name: this$.name,
	          text: "setup failed with exit code " + exitCode
	        });
	        process.exit(exitCode);
	      }
	      return done();
	    });
	    return x$;
	  };
	  ServiceSetup.prototype.write = function(text){
	    return this.emit('output', {
	      name: this.name,
	      text: text
	    });
	  };
	  return ServiceSetup;
	}(EventEmitter));
	module.exports = ServiceSetup;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var cyan, fs, yaml, AppSyncer, Logger;
	cyan = __webpack_require__(3).cyan;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	AppSyncer = __webpack_require__(55);
	Logger = __webpack_require__(9).Logger;
	module.exports = function(){
	  var appConfig, x$, logger, ref$, y$, syncer;
	  appConfig = yaml.safeLoad(fs.readFileSync('application.yml', 'utf-8'));
	  x$ = logger = new Logger(Object.keys((ref$ = appConfig.services) != null
	    ? ref$
	    : {}));
	  x$.log({
	    name: 'exo-sync',
	    text: "Syncing application " + cyan(appConfig.name)
	  });
	  y$ = syncer = new AppSyncer(appConfig);
	  y$.on('output', logger.log);
	  y$.on('sync-failed', function(){
	    return logger.log({
	      name: 'exo-sync',
	      text: "Some services failed to sync"
	    });
	  });
	  y$.on('sync-success', function(){
	    return logger.log({
	      name: 'exo-sync',
	      text: 'Sync successful'
	    });
	  });
	  y$.startSyncing();
	  return y$;
	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var async, red, EventEmitter, ServiceSyncer, ref$, flatten, filter, AppSyncer;
	async = __webpack_require__(26);
	red = __webpack_require__(3).red;
	EventEmitter = __webpack_require__(27).EventEmitter;
	ServiceSyncer = __webpack_require__(56);
	ref$ = __webpack_require__(11), flatten = ref$.flatten, filter = ref$.filter;
	AppSyncer = (function(superclass){
	  var prototype = extend$((import$(AppSyncer, superclass).displayName = 'AppSyncer', AppSyncer), superclass).prototype, constructor = AppSyncer;
	  function AppSyncer(appConfig){
	    this.appConfig = appConfig;
	  }
	  AppSyncer.prototype.startSyncing = function(){
	    var syncers, res$, type, lresult$, serviceName, ref$, ref1$, service, x$, syncer, this$ = this;
	    res$ = [];
	    for (type in this.appConfig.services) {
	      lresult$ = [];
	      for (serviceName in ref$ = (ref1$ = this.appConfig.services[type]) != null
	        ? ref1$
	        : {}) {
	        service = ref$[serviceName];
	        x$ = new ServiceSyncer(serviceName, {
	          root: service.location
	        });
	        x$.on('output', fn$);
	        lresult$.push(x$);
	      }
	      res$.push(lresult$);
	    }
	    syncers = res$;
	    return async.parallel((function(){
	      var i$, ref$, len$, results$ = [];
	      for (i$ = 0, len$ = (ref$ = flatten(syncers)).length; i$ < len$; ++i$) {
	        syncer = ref$[i$];
	        results$.push(syncer.start);
	      }
	      return results$;
	    }()), function(err, exitCodes){
	      switch (false) {
	      case !this$._countErrors(exitCodes):
	        return this$.emit('sync-failed');
	      default:
	        return this$.emit('sync-success');
	      }
	    });
	    function fn$(){
	      return this$.emit('output', arguments[0]);
	    }
	  };
	  AppSyncer.prototype._countErrors = function(exitCodes){
	    return exitCodes.filter(function(code){
	      return code !== 0;
	    }).length;
	  };
	  return AppSyncer;
	}(EventEmitter));
	module.exports = AppSyncer;
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var EventEmitter, fs, yaml, ObservableProcess, path, ServiceSyncer;
	EventEmitter = __webpack_require__(27).EventEmitter;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	ObservableProcess = __webpack_require__(30);
	path = __webpack_require__(16);
	ServiceSyncer = (function(superclass){
	  var prototype = extend$((import$(ServiceSyncer, superclass).displayName = 'ServiceSyncer', ServiceSyncer), superclass).prototype, constructor = ServiceSyncer;
	  function ServiceSyncer(name, config){
	    this.name = name;
	    this.config = config;
	    this.write = bind$(this, 'write', prototype);
	    this.start = bind$(this, 'start', prototype);
	  }
	  ServiceSyncer.prototype.start = function(done){
	    var x$, this$ = this;
	    switch (false) {
	    case !!this._isExternalService():
	      return done(null, 0);
	    }
	    x$ = new ObservableProcess("git pull", {
	      cwd: this.config.root,
	      stdout: {
	        write: this.write
	      },
	      stderr: {
	        write: this.write
	      }
	    });
	    x$.on('ended', function(exitCode){
	      switch (false) {
	      case exitCode !== 0:
	        this$.write('Sync ok');
	        break;
	      default:
	        this$.write('Sync error');
	      }
	      return done(null, exitCode);
	    });
	    return x$;
	  };
	  ServiceSyncer.prototype._isExternalService = function(){
	    return this.config.root.split('/')[0] === '..';
	  };
	  ServiceSyncer.prototype.write = function(text){
	    return this.emit('output', {
	      name: this.name,
	      text: text
	    });
	  };
	  return ServiceSyncer;
	}(EventEmitter));
	module.exports = ServiceSyncer;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var AppTester, ref$, cyan, green, red, fs, yaml, Logger, path, ServiceTester;
	AppTester = __webpack_require__(58);
	ref$ = __webpack_require__(3), cyan = ref$.cyan, green = ref$.green, red = ref$.red;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	Logger = __webpack_require__(9).Logger;
	path = __webpack_require__(16);
	ServiceTester = __webpack_require__(59);
	module.exports = function(){
	  var logger;
	  switch (false) {
	  case !cwdIsService():
	    return testService();
	  case !cwdIsApp():
	    return testApp();
	  default:
	    return logger = new Logger().log({
	      name: 'exo-test',
	      text: "Tests do not exist. Not in service or application directory."
	    });
	  }
	};
	function cwdIsService(){
	  var e;
	  try {
	    return fs.statSync('service.yml');
	  } catch (e$) {
	    e = e$;
	    return false;
	  }
	}
	function cwdIsApp(){
	  var e;
	  try {
	    return fs.statSync('application.yml');
	  } catch (e$) {
	    e = e$;
	    return false;
	  }
	}
	function testService(){
	  var serviceName, x$, logger, y$, this$ = this;
	  serviceName = path.basename(process.cwd());
	  x$ = logger = new Logger([serviceName]);
	  x$.log({
	    name: 'exo-test',
	    text: "Testing service '" + serviceName + "'"
	  });
	  y$ = new ServiceTester(serviceName, {
	    root: process.cwd()
	  });
	  y$.on('output', function(data){
	    return logger.log(data);
	  });
	  y$.on('service-tests-passed', function(name){
	    return logger.log({
	      name: 'exo-test',
	      text: name + " works"
	    });
	  });
	  y$.on('service-tests-failed', function(name){
	    return logger.log({
	      name: 'exo-test',
	      text: name + " is broken"
	    });
	  });
	  y$.on('service-tests-skipped', function(name){
	    return logger.log({
	      name: 'exo-test',
	      text: name + " has no tests, skipping"
	    });
	  });
	  y$.start();
	  return y$;
	}
	function testApp(){
	  var appConfig, x$, logger, y$, appTester;
	  appConfig = yaml.safeLoad(fs.readFileSync('application.yml', 'utf8'));
	  x$ = logger = new Logger(Object.keys(appConfig.services));
	  x$.log({
	    name: 'exo-test',
	    text: "Testing application '" + appConfig.name + "'"
	  });
	  y$ = appTester = new AppTester(appConfig);
	  y$.on('output', function(data){
	    return logger.log(data);
	  });
	  y$.on('all-tests-passed', function(){
	    return logger.log({
	      name: 'exo-test',
	      text: 'All tests passed'
	    });
	  });
	  y$.on('all-tests-failed', function(){
	    logger.log({
	      name: 'exo-test',
	      text: 'Tests failed'
	    });
	    return process.exit(1);
	  });
	  y$.on('service-tests-passed', function(name){
	    return logger.log({
	      name: 'exo-test',
	      text: name + " works"
	    });
	  });
	  y$.on('service-tests-failed', function(name){
	    return logger.log({
	      name: 'exo-test',
	      text: name + " is broken"
	    });
	  });
	  y$.on('service-tests-skipped', function(name){
	    return logger.log({
	      name: 'exo-test',
	      text: name + " has no tests, skipping"
	    });
	  });
	  y$.startTesting();
	  return y$;
	}

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var async, EventEmitter, path, filter, ServiceTester, AppTester;
	async = __webpack_require__(26);
	EventEmitter = __webpack_require__(27).EventEmitter;
	path = __webpack_require__(16);
	filter = __webpack_require__(11).filter;
	ServiceTester = __webpack_require__(59);
	AppTester = (function(superclass){
	  var prototype = extend$((import$(AppTester, superclass).displayName = 'AppTester', AppTester), superclass).prototype, constructor = AppTester;
	  function AppTester(appConfig){
	    this.appConfig = appConfig;
	  }
	  AppTester.prototype.startTesting = function(){
	    var testers, type, serviceName, ref$, serviceData, serviceDir, x$, tester, this$ = this;
	    testers = [];
	    for (type in this.appConfig.services) {
	      for (serviceName in ref$ = this.appConfig.services[type]) {
	        serviceData = ref$[serviceName];
	        serviceDir = path.join(process.cwd(), serviceData.location);
	        testers.push((x$ = new ServiceTester(serviceName, {
	          root: serviceDir
	        }), x$.on('output', fn$), x$.on('service-tests-passed', fn1$), x$.on('service-tests-failed', fn2$), x$.on('service-tests-skipped', fn3$), x$));
	      }
	    }
	    return async.series((function(){
	      var i$, ref$, len$, results$ = [];
	      for (i$ = 0, len$ = (ref$ = testers).length; i$ < len$; ++i$) {
	        tester = ref$[i$];
	        results$.push(tester.start);
	      }
	      return results$;
	    }()), function(err, exitCodes){
	      switch (false) {
	      case !err:
	        return this$.emit('all-tests-failed');
	      case !this$._containsNonZero(exitCodes):
	        return this$.emit('all-tests-failed');
	      default:
	        return this$.emit('all-tests-passed');
	      }
	    });
	    function fn$(data){
	      return this$.emit('output', data);
	    }
	    function fn1$(name){
	      return this$.emit('service-tests-passed', name);
	    }
	    function fn2$(name){
	      return this$.emit('service-tests-failed', name);
	    }
	    function fn3$(name){
	      return this$.emit('service-tests-skipped', name);
	    }
	  };
	  AppTester.prototype._containsNonZero = function(exitCodes){
	    var this$ = this;
	    return exitCodes.filter((function(it){
	      return it > 0;
	    })).length > 0;
	  };
	  return AppTester;
	}(EventEmitter));
	module.exports = AppTester;
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.5.0
	var EventEmitter, callArgs, fs, yaml, ObservableProcess, path, ServiceTester;
	EventEmitter = __webpack_require__(27).EventEmitter;
	callArgs = __webpack_require__(9).callArgs;
	fs = __webpack_require__(6);
	yaml = __webpack_require__(8);
	ObservableProcess = __webpack_require__(30);
	path = __webpack_require__(16);
	ServiceTester = (function(superclass){
	  var prototype = extend$((import$(ServiceTester, superclass).displayName = 'ServiceTester', ServiceTester), superclass).prototype, constructor = ServiceTester;
	  function ServiceTester(name, config){
	    this.name = name;
	    this.config = config;
	    this.write = bind$(this, 'write', prototype);
	    this.start = bind$(this, 'start', prototype);
	    this.serviceConfig = yaml.safeLoad(fs.readFileSync(path.join(this.config.root, 'service.yml'), 'utf8'));
	  }
	  ServiceTester.prototype.start = function(done){
	    var x$, this$ = this;
	    if (!this.serviceConfig.tests) {
	      this.emit('service-tests-skipped', this.name);
	      return done();
	    }
	    x$ = new ObservableProcess(callArgs(this._createCommand(this.serviceConfig.tests)), {
	      cwd: this.config.root,
	      env: this.config,
	      stdout: {
	        write: this.write
	      },
	      stderr: {
	        write: this.write
	      }
	    });
	    x$.on('ended', function(exitCode){
	      if (exitCode > 0) {
	        this$.emit('service-tests-failed', this$.name);
	      } else {
	        this$.emit('service-tests-passed', this$.name);
	      }
	      return typeof done == 'function' ? done(null, exitCode) : void 8;
	    });
	    return x$;
	  };
	  ServiceTester.prototype._createCommand = function(command){
	    if (this._isLocalCommand(command)) {
	      command = path.join(this.config.root, command);
	    }
	    return command;
	  };
	  ServiceTester.prototype._isLocalCommand = function(command){
	    return command.substr(0, 2) === './';
	  };
	  ServiceTester.prototype.write = function(text){
	    return this.emit('output', {
	      name: this.name,
	      text: text
	    });
	  };
	  return ServiceTester;
	}(EventEmitter));
	module.exports = ServiceTester;
	function bind$(obj, key, target){
	  return function(){ return (target || obj)[key].apply(obj, arguments) };
	}
	function extend$(sub, sup){
	  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
	  (sub.prototype = new fun).constructor = sub;
	  if (typeof sup.extended == 'function') sup.extended(sub);
	  return sub;
	}
	function import$(obj, src){
	  var own = {}.hasOwnProperty;
	  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	  return obj;
	}

/***/ },
/* 60 */
/***/ function(module, exports) {

	module.exports = {
		"name": "exosphere-sdk",
		"version": "0.9.0",
		"author": "Kevin Goslar",
		"bin": {
			"exo": "bin/exo"
		},
		"dependencies": {
			"abbrev": "1.0.9",
			"chalk": "1.1.3",
			"prelude-ls": "1.1.2",
			"update-notifier": "1.0.3"
		},
		"description": "SDK for the Exosphere framework",
		"devDependencies": {
			"async": "2.1.4",
			"chai": "3.5.0",
			"cucumber": "1.3.1",
			"cucumber-snippets-livescript": "1.0.1",
			"dependency-lint": "4.3.0",
			"dim-console": "0.4.4",
			"fs-extra": "1.0.0",
			"jsdiff-console": "2.2.1",
			"livescript": "1.5.0",
			"nitroglycerin": "1.1.2",
			"o-tools": "0.7.0",
			"o-tools-livescript": "1.2.3",
			"observable-process": "3.2.0",
			"ps-tree": "1.1.0",
			"zombie": "5.0.5"
		},
		"engines": {
			"npm": ">= 3.0.0"
		},
		"files": [
			"bin/exo",
			"bin/exo.cmd",
			"dist",
			"npm-shrinkwrap.json"
		],
		"homepage": "https://github.com/Originate/exosphere-sdk",
		"license": "ISC",
		"main": "dist/cli.js",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/Originate/exosphere-sdk.git"
		},
		"scripts": {
			"prepublish": "node_modules/.bin/build",
			"test": "bin/spec"
		}
	};

/***/ },
/* 61 */
/***/ function(module, exports) {

	module.exports = require("update-notifier");

/***/ }
/******/ ]);