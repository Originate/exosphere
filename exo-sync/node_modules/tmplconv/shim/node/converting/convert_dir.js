/**
 * Convert files in a directory.
 * @function convertDir
 * @param {string} srcDir - Source directory path.
 * @param {string} destDir - Destination directory path.
 * @param {object} [options] - Optional settings.
 * @param {string|string[]} [options.pattern] - Filename pattern.
 * @param {string|string[]} [options.ignore] - Filename pattern.
 * @param {object} [options.rule] - Convert map.
 * @param {string} [options.mode='644'] - File permission to generate.
 * @param {boolean} [options.clean=false] - Cleanup destination directory before convert.
 * @param {boolean} [options.once=false] - Write only first time. Skip if already exists.
 * @param {function} [options.out] - Convert output file name.
 * @returns {Promise}
 */
'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var co = require('co');
var argx = require('argx');
var path = require('path');

var _require = require('asfs');

var existsAsync = _require.existsAsync;

var rimraf = require('rimraf');
var aglob = require('aglob');
var convertString = require('./convert_string');

/** @lends convertDir */
function convertDir(srcDir, destDir) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var args = argx(arguments);
  options = args.pop('object');

  var pattern = options.pattern || '**/*.*';
  var ignore = [].concat(options.ignore || []);
  var rule = options.rule || {};
  var out = options.out;
  var once = !!options.once;
  var clean = !!options.clean;

  return co(_regenerator2.default.mark(function _callee() {
    var exists, filenames, results, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, filename, src, dest, result;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return existsAsync(srcDir);

          case 2:
            exists = _context.sent;

            if (exists) {
              _context.next = 5;
              break;
            }

            throw new Error('srcDir not exists: ' + srcDir);

          case 5:
            if (!clean) {
              _context.next = 8;
              break;
            }

            _context.next = 8;
            return new _promise2.default(function (resolve, reject) {
              return rimraf(destDir, function (err) {
                return err ? reject(err) : resolve();
              });
            });

          case 8:
            _context.next = 10;
            return aglob(pattern, {
              cwd: srcDir,
              ignore: ignore
            });

          case 10:
            filenames = _context.sent;

            filenames = filenames.filter(function (filename, i, filenames) {
              return filenames.indexOf(filename) === i;
            });
            results = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context.prev = 16;
            _iterator = (0, _getIterator3.default)(filenames);

          case 18:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context.next = 30;
              break;
            }

            filename = _step.value;
            src = path.resolve(srcDir, filename);
            dest = path.resolve(destDir, convertString(filename, rule));

            if (out) {
              dest = out(dest);
            }
            _context.next = 25;
            return require('./convert')(src, dest, {
              rule: rule,
              once: once,
              mode: options.mode
            });

          case 25:
            result = _context.sent;

            results.push(result);

          case 27:
            _iteratorNormalCompletion = true;
            _context.next = 18;
            break;

          case 30:
            _context.next = 36;
            break;

          case 32:
            _context.prev = 32;
            _context.t0 = _context['catch'](16);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 36:
            _context.prev = 36;
            _context.prev = 37;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 39:
            _context.prev = 39;

            if (!_didIteratorError) {
              _context.next = 42;
              break;
            }

            throw _iteratorError;

          case 42:
            return _context.finish(39);

          case 43:
            return _context.finish(36);

          case 44:
            return _context.abrupt('return', results);

          case 45:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this, [[16, 32, 36, 44], [37,, 39, 43]]);
  }));
}

module.exports = convertDir;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbnZlcnRfZGlyLmpzIl0sIm5hbWVzIjpbImNvIiwicmVxdWlyZSIsImFyZ3giLCJwYXRoIiwiZXhpc3RzQXN5bmMiLCJyaW1yYWYiLCJhZ2xvYiIsImNvbnZlcnRTdHJpbmciLCJjb252ZXJ0RGlyIiwic3JjRGlyIiwiZGVzdERpciIsIm9wdGlvbnMiLCJhcmdzIiwiYXJndW1lbnRzIiwicG9wIiwicGF0dGVybiIsImlnbm9yZSIsImNvbmNhdCIsInJ1bGUiLCJvdXQiLCJvbmNlIiwiY2xlYW4iLCJleGlzdHMiLCJFcnJvciIsInJlc29sdmUiLCJyZWplY3QiLCJlcnIiLCJjd2QiLCJmaWxlbmFtZXMiLCJmaWx0ZXIiLCJmaWxlbmFtZSIsImkiLCJpbmRleE9mIiwicmVzdWx0cyIsInNyYyIsImRlc3QiLCJtb2RlIiwicmVzdWx0IiwicHVzaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLEtBQUtDLFFBQVEsSUFBUixDQUFYO0FBQ0EsSUFBTUMsT0FBT0QsUUFBUSxNQUFSLENBQWI7QUFDQSxJQUFNRSxPQUFPRixRQUFRLE1BQVIsQ0FBYjs7ZUFDd0JBLFFBQVEsTUFBUixDOztJQUFoQkcsVyxZQUFBQSxXOztBQUNSLElBQU1DLFNBQVNKLFFBQVEsUUFBUixDQUFmO0FBQ0EsSUFBTUssUUFBUUwsUUFBUSxPQUFSLENBQWQ7QUFDQSxJQUFNTSxnQkFBZ0JOLFFBQVEsa0JBQVIsQ0FBdEI7O0FBRUE7QUFDQSxTQUFTTyxVQUFULENBQXFCQyxNQUFyQixFQUE2QkMsT0FBN0IsRUFBb0Q7QUFBQSxNQUFkQyxPQUFjLHlEQUFKLEVBQUk7O0FBQ2xELE1BQUlDLE9BQU9WLEtBQUtXLFNBQUwsQ0FBWDtBQUNBRixZQUFVQyxLQUFLRSxHQUFMLENBQVMsUUFBVCxDQUFWOztBQUVBLE1BQUlDLFVBQVVKLFFBQVFJLE9BQVIsSUFBbUIsUUFBakM7QUFDQSxNQUFJQyxTQUFTLEdBQUdDLE1BQUgsQ0FBVU4sUUFBUUssTUFBUixJQUFrQixFQUE1QixDQUFiO0FBQ0EsTUFBSUUsT0FBT1AsUUFBUU8sSUFBUixJQUFnQixFQUEzQjtBQUNBLE1BQUlDLE1BQU1SLFFBQVFRLEdBQWxCO0FBQ0EsTUFBSUMsT0FBTyxDQUFDLENBQUNULFFBQVFTLElBQXJCO0FBQ0EsTUFBSUMsUUFBUSxDQUFDLENBQUNWLFFBQVFVLEtBQXRCOztBQUVBLFNBQU9yQiw4QkFBRztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFDV0ksWUFBWUssTUFBWixDQURYOztBQUFBO0FBQ0phLGtCQURJOztBQUFBLGdCQUVIQSxNQUZHO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQUdBLElBQUlDLEtBQUoseUJBQWdDZCxNQUFoQyxDQUhBOztBQUFBO0FBQUEsaUJBS0pZLEtBTEk7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxtQkFNQSxzQkFBWSxVQUFDRyxPQUFELEVBQVVDLE1BQVY7QUFBQSxxQkFDaEJwQixPQUFPSyxPQUFQLEVBQWdCLFVBQUNnQixHQUFEO0FBQUEsdUJBQVNBLE1BQU1ELE9BQU9DLEdBQVAsQ0FBTixHQUFvQkYsU0FBN0I7QUFBQSxlQUFoQixDQURnQjtBQUFBLGFBQVosQ0FOQTs7QUFBQTtBQUFBO0FBQUEsbUJBVWNsQixNQUFNUyxPQUFOLEVBQWU7QUFDbkNZLG1CQUFLbEIsTUFEOEI7QUFFbkNPO0FBRm1DLGFBQWYsQ0FWZDs7QUFBQTtBQVVKWSxxQkFWSTs7QUFjUkEsd0JBQVlBLFVBQVVDLE1BQVYsQ0FBaUIsVUFBQ0MsUUFBRCxFQUFXQyxDQUFYLEVBQWNILFNBQWQ7QUFBQSxxQkFBNEJBLFVBQVVJLE9BQVYsQ0FBa0JGLFFBQWxCLE1BQWdDQyxDQUE1RDtBQUFBLGFBQWpCLENBQVo7QUFDSUUsbUJBZkksR0FlTSxFQWZOO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtREFnQmFMLFNBaEJiOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBZ0JDRSxvQkFoQkQ7QUFpQkZJLGVBakJFLEdBaUJJL0IsS0FBS3FCLE9BQUwsQ0FBYWYsTUFBYixFQUFxQnFCLFFBQXJCLENBakJKO0FBa0JGSyxnQkFsQkUsR0FrQktoQyxLQUFLcUIsT0FBTCxDQUFhZCxPQUFiLEVBQXNCSCxjQUFjdUIsUUFBZCxFQUF3QlosSUFBeEIsQ0FBdEIsQ0FsQkw7O0FBbUJOLGdCQUFJQyxHQUFKLEVBQVM7QUFDUGdCLHFCQUFPaEIsSUFBSWdCLElBQUosQ0FBUDtBQUNEO0FBckJLO0FBQUEsbUJBc0JhbEMsUUFBUSxXQUFSLEVBQXFCaUMsR0FBckIsRUFBMEJDLElBQTFCLEVBQWdDO0FBQ2pEakIsd0JBRGlEO0FBRWpERSx3QkFGaUQ7QUFHakRnQixvQkFBTXpCLFFBQVF5QjtBQUhtQyxhQUFoQyxDQXRCYjs7QUFBQTtBQXNCRkMsa0JBdEJFOztBQTJCTkosb0JBQVFLLElBQVIsQ0FBYUQsTUFBYjs7QUEzQk07QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBLDZDQTZCREosT0E3QkM7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBSCxFQUFQO0FBK0JEOztBQUVETSxPQUFPQyxPQUFQLEdBQWlCaEMsVUFBakIiLCJmaWxlIjoiY29udmVydF9kaXIuanMiLCJzb3VyY2VSb290IjoibGliIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb252ZXJ0IGZpbGVzIGluIGEgZGlyZWN0b3J5LlxuICogQGZ1bmN0aW9uIGNvbnZlcnREaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNEaXIgLSBTb3VyY2UgZGlyZWN0b3J5IHBhdGguXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciAtIERlc3RpbmF0aW9uIGRpcmVjdG9yeSBwYXRoLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFtvcHRpb25zLnBhdHRlcm5dIC0gRmlsZW5hbWUgcGF0dGVybi5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbb3B0aW9ucy5pZ25vcmVdIC0gRmlsZW5hbWUgcGF0dGVybi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5ydWxlXSAtIENvbnZlcnQgbWFwLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1vZGU9JzY0NCddIC0gRmlsZSBwZXJtaXNzaW9uIHRvIGdlbmVyYXRlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbGVhbj1mYWxzZV0gLSBDbGVhbnVwIGRlc3RpbmF0aW9uIGRpcmVjdG9yeSBiZWZvcmUgY29udmVydC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMub25jZT1mYWxzZV0gLSBXcml0ZSBvbmx5IGZpcnN0IHRpbWUuIFNraXAgaWYgYWxyZWFkeSBleGlzdHMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5vdXRdIC0gQ29udmVydCBvdXRwdXQgZmlsZSBuYW1lLlxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjbyA9IHJlcXVpcmUoJ2NvJylcbmNvbnN0IGFyZ3ggPSByZXF1aXJlKCdhcmd4JylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHsgZXhpc3RzQXN5bmMgfSA9IHJlcXVpcmUoJ2FzZnMnKVxuY29uc3QgcmltcmFmID0gcmVxdWlyZSgncmltcmFmJylcbmNvbnN0IGFnbG9iID0gcmVxdWlyZSgnYWdsb2InKVxuY29uc3QgY29udmVydFN0cmluZyA9IHJlcXVpcmUoJy4vY29udmVydF9zdHJpbmcnKVxuXG4vKiogQGxlbmRzIGNvbnZlcnREaXIgKi9cbmZ1bmN0aW9uIGNvbnZlcnREaXIgKHNyY0RpciwgZGVzdERpciwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBhcmdzID0gYXJneChhcmd1bWVudHMpXG4gIG9wdGlvbnMgPSBhcmdzLnBvcCgnb2JqZWN0JylcblxuICBsZXQgcGF0dGVybiA9IG9wdGlvbnMucGF0dGVybiB8fCAnKiovKi4qJ1xuICBsZXQgaWdub3JlID0gW10uY29uY2F0KG9wdGlvbnMuaWdub3JlIHx8IFtdKVxuICBsZXQgcnVsZSA9IG9wdGlvbnMucnVsZSB8fCB7fVxuICBsZXQgb3V0ID0gb3B0aW9ucy5vdXRcbiAgbGV0IG9uY2UgPSAhIW9wdGlvbnMub25jZVxuICBsZXQgY2xlYW4gPSAhIW9wdGlvbnMuY2xlYW5cblxuICByZXR1cm4gY28oZnVuY3Rpb24gKiAoKSB7XG4gICAgbGV0IGV4aXN0cyA9IHlpZWxkIGV4aXN0c0FzeW5jKHNyY0RpcilcbiAgICBpZiAoIWV4aXN0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBzcmNEaXIgbm90IGV4aXN0czogJHtzcmNEaXJ9YClcbiAgICB9XG4gICAgaWYgKGNsZWFuKSB7XG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICByaW1yYWYoZGVzdERpciwgKGVycikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCkpXG4gICAgICApXG4gICAgfVxuICAgIGxldCBmaWxlbmFtZXMgPSB5aWVsZCBhZ2xvYihwYXR0ZXJuLCB7XG4gICAgICBjd2Q6IHNyY0RpcixcbiAgICAgIGlnbm9yZVxuICAgIH0pXG4gICAgZmlsZW5hbWVzID0gZmlsZW5hbWVzLmZpbHRlcigoZmlsZW5hbWUsIGksIGZpbGVuYW1lcykgPT4gZmlsZW5hbWVzLmluZGV4T2YoZmlsZW5hbWUpID09PSBpKVxuICAgIGxldCByZXN1bHRzID0gW11cbiAgICBmb3IgKGxldCBmaWxlbmFtZSBvZiBmaWxlbmFtZXMpIHtcbiAgICAgIGxldCBzcmMgPSBwYXRoLnJlc29sdmUoc3JjRGlyLCBmaWxlbmFtZSlcbiAgICAgIGxldCBkZXN0ID0gcGF0aC5yZXNvbHZlKGRlc3REaXIsIGNvbnZlcnRTdHJpbmcoZmlsZW5hbWUsIHJ1bGUpKVxuICAgICAgaWYgKG91dCkge1xuICAgICAgICBkZXN0ID0gb3V0KGRlc3QpXG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0geWllbGQgcmVxdWlyZSgnLi9jb252ZXJ0Jykoc3JjLCBkZXN0LCB7XG4gICAgICAgIHJ1bGUsXG4gICAgICAgIG9uY2UsXG4gICAgICAgIG1vZGU6IG9wdGlvbnMubW9kZVxuICAgICAgfSlcbiAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydERpclxuIl19