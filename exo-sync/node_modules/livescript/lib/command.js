// Generated by LiveScript 1.5.0
var LiveScript, path, fs, util, prelude, each, breakList, lines, unlines, take, keys, filter, dasherize, map, ref$, parseOptions, generateHelp, nameFromPath, SourceNode, version, this$ = this, slice$ = [].slice;
LiveScript = require('..');
path = require('path');
fs = require('fs');
util = require('util');
prelude = require('prelude-ls'), each = prelude.each, breakList = prelude.breakList, lines = prelude.lines, unlines = prelude.unlines, take = prelude.take, keys = prelude.keys, filter = prelude.filter, dasherize = prelude.dasherize, map = prelude.map;
ref$ = require('./options'), parseOptions = ref$.parse, generateHelp = ref$.generateHelp;
nameFromPath = require('./util').nameFromPath;
SourceNode = require('source-map').SourceNode;
version = LiveScript.VERSION;
(function(it){
  return module.exports = it;
})(function(args, arg$){
  var ref$, say, sayWithTimestamp, warn, die, p, pp, ppp, fileExists, dasherizeVars, startsWith, o, positional, e, validMapValues, toInsert, that, filename, jsonCallback;
  ref$ = arg$ != null
    ? arg$
    : {}, say = ref$.say, sayWithTimestamp = ref$.sayWithTimestamp, warn = ref$.warn, die = ref$.die;
  say == null && (say = console.log);
  sayWithTimestamp == null && (sayWithTimestamp = util.log);
  warn == null && (warn = console.error);
  die == null && (die = function(message){
    console.error(message);
    process.exit(1);
  });
  p = function(){
    var args, res$, i$, to$;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    each(console.dir, args);
  };
  pp = function(x, showHidden, depth){
    say(util.inspect(x, showHidden, depth, !process.env.NODE_DISABLE_COLORS));
  };
  ppp = function(it){
    pp(it, true, null);
  };
  fileExists = function(path){
    try {
      fs.statSync(path);
      return true;
    } catch (e$) {}
  };
  dasherizeVars = function(str){
    if (/^[a-z]/.exec(str)) {
      return dasherize(str);
    } else {
      return str;
    }
  };
  startsWith = function(str){
    var this$ = this;
    return function(it){
      return it.indexOf(str) === 0;
    };
  };
  try {
    o = parseOptions(args);
    positional = o._;
  } catch (e$) {
    e = e$;
    die(e.message);
  }
  switch (false) {
  case !o.nodejs:
    forkNode();
    break;
  case !o.version:
    say("LiveScript version " + version);
    break;
  case !o.help:
    say(generateHelp({
      interpolate: {
        version: version
      }
    }));
    break;
  default:
    validMapValues = ['none', 'linked', 'linked-src', 'embedded', 'debug'];
    if (!in$(o.map, validMapValues)) {
      die("Option --map must be either: " + validMapValues.join(', '));
    }
    o.run = !(o.compile || (o.compile = o.output));
    if (args === process.argv) {
      process.argv[0] = process.argv[1];
      toInsert = o.stdin
        ? positional
        : o.run
          ? positional.splice(1, 9e9)
          : [];
      (ref$ = process.argv).splice.apply(ref$, [2, 9e9].concat(slice$.call(toInsert)));
    }
    if (that = o.require) {
      filename = module.filename;
      module.filename = '.';
      each(function(it){
        return global[nameFromPath(it)] = require(it);
      })(
      that);
      module.filename = filename;
    }
    switch (false) {
    case !o.eval:
      jsonCallback = function(input){
        if (o.prelude) {
          import$(global, prelude);
        }
        o.runContext = JSON.parse(input.toString());
        compileScript('', o.eval);
      };
      if (positional.length && (o.json || /\.json$/.test(positional[0]))) {
        o.json = true;
        fshoot('readFile', positional[0], jsonCallback);
      } else if (o.json) {
        getStdin(jsonCallback);
      } else {
        compileScript('', o.eval);
      }
      break;
    case !o.stdin:
      compileStdin();
      break;
    case !positional.length:
      compileScripts();
      break;
    case !require('tty').isatty(0):
      say("LiveScript " + version + " - use 'lsc --help' for more information");
      repl();
      break;
    default:
      compileStdin();
    }
  }
  function fshoot(name, arg, callback){
    fs[name](arg, function(e, result){
      if (e) {
        die(e.stack || e);
      }
      callback(result);
    });
  }
  function compileScripts(){
    positional.forEach(function(it){
      walk(it, path.normalize(it), true);
    });
    function walk(source, base, top){
      function work(){
        fshoot('readFile', source, function(it){
          compileScript(source, it + "", base);
        });
      }
      fs.stat(source, function(e, stats){
        if (e) {
          if (!top || /(?:\.ls|\/)$/.test(source)) {
            die("Can't find: " + source);
          }
          walk(source + ".ls", base);
          return;
        }
        if (stats.isDirectory()) {
          if (!o.run) {
            fshoot('readdir', source, function(it){
              it.forEach(function(it){
                walk(source + "/" + it, base);
              });
            });
            return;
          }
          source += '/index.ls';
        }
        if (top || '.ls' === source.slice(-3)) {
          if (o.watch) {
            watch(source, work);
          } else {
            work();
          }
        }
      });
    }
  }
  function compileScript(filename, input, base){
    var options, t, json, run, print, ref$, e;
    options = {
      filename: filename,
      outputFilename: outputFilename(filename, o.json),
      bare: o.bare,
      'const': o['const'],
      map: o.map,
      header: o.header
    };
    t = {
      input: input,
      options: options
    };
    try {
      if (o.lex || o.tokens || o.ast) {
        LiveScript.emit('lex', t);
        t.tokens = LiveScript.tokens(t.input, {
          raw: o.lex
        });
        if (o.lex || o.tokens) {
          printTokens(t.tokens);
          throw null;
        }
        LiveScript.emit('parse', t);
        t.ast = LiveScript.ast(t.tokens);
        say(o.json
          ? t.ast.stringify(2)
          : ''.trim.call(t.ast));
        throw null;
      }
      json = o.json || /\.json\.ls$/.test(filename);
      run = o.run || o.eval;
      if (run) {
        LiveScript.emit('compile', t);
        print = json || o.print;
        t.output = LiveScript.compile(t.input, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$.run = run, ref$.print = print, ref$));
        LiveScript.emit('run', t);
        t.result = LiveScript.run(o.map === 'none'
          ? t.output
          : t.output.code, options, {
          js: true,
          context: o.runContext
        });
        switch (false) {
        case !json:
          say(JSON.stringify(t.result, null, 2));
          break;
        case !o.print:
          say(t.result);
        }
        throw null;
      }
      LiveScript.emit('compile', t);
      t.output = LiveScript.compile(t.input, (ref$ = {}, import$(ref$, options), ref$.json = json, ref$.print = o.print, ref$));
      LiveScript.emit('write', t);
      if (o.print || !filename) {
        say((o.map === 'none'
          ? t.output
          : t.output.code).trimRight());
      } else {
        writeJS(filename, t.output, t.input, base, json);
      }
    } catch (e$) {
      e = e$;
      if (e != null) {
        if (LiveScript.listeners('failure').length) {
          LiveScript.emit('failure', e, t);
        } else {
          if (filename) {
            warn("Failed at: " + filename);
          }
          if (!(e instanceof SyntaxError || /^Parse error /.test(e.message))) {
            e = e.stack || e;
          }
          if (o.watch) {
            warn(e + '\x07');
          } else {
            die(e);
          }
        }
        return;
      }
    }
    LiveScript.emit('success', t);
  }
  function getStdin(cb){
    var x$, code;
    x$ = process.openStdin();
    code = '';
    x$.on('data', function(it){
      code += it;
    });
    x$.on('end', function(){
      cb(code);
    });
    x$.on('data', function(){
      var ref$;
      if ((ref$ = code.slice(-3)) === '\x04\r\n' || ref$ === '\x1a\r\n') {
        cb(code.slice(0, -3));
        x$.destroy();
      }
    });
  }
  function compileStdin(){
    getStdin(function(input){
      compileScript('', input);
    });
  }
  function watch(source, action){
    (function repeat(ptime){
      fshoot('stat', source, function(arg$){
        var mtime;
        mtime = arg$.mtime;
        if (ptime ^ mtime) {
          action();
        }
        setTimeout(repeat, 500, mtime);
      });
    }.call(this, 0));
  }
  function writeJS(source, js, input, base, json){
    var filename, dir, that, jsPath;
    filename = outputFilename(source, json);
    dir = path.dirname(source);
    if (that = o.output) {
      dir = path.join(that, dir.slice(base === '.'
        ? 0
        : base.length));
    }
    source = path.normalize(source);
    jsPath = path.join(dir, filename);
    function compile(){
      fs.writeFile(jsPath, js.toString() || '\n', function(e){
        if (e) {
          return warn(e);
        }
        if (o.watch || o.debug) {
          sayWithTimestamp(source + " => " + jsPath);
        }
      });
    }
    function compileWithMap(){
      fs.writeFile(jsPath, js.code || '\n', function(e){
        var mapPath;
        if (e) {
          return warn(e);
        }
        if (o.map === 'linked' || o.map === "debug") {
          mapPath = jsPath + ".map";
          fs.writeFile(mapPath, js.map || '\n', function(e2){
            if (e2) {
              return warn(e2);
            }
            if (o.map === "debug") {
              fs.writeFile(mapPath + ".debug", js.debug || '\n', function(e3){
                if (o.watch || o.debug) {
                  sayWithTimestamp(source + " => " + jsPath + ", " + mapPath + "[.debug]");
                }
              });
            } else {
              if (o.watch || o.debug) {
                sayWithTimestamp(source + " => " + jsPath + ", " + mapPath);
              }
            }
          });
        } else {
          if (o.watch || o.debug) {
            sayWithTimestamp(source + " => " + jsPath);
          }
        }
      });
    }
    fs.stat(dir, function(e){
      if (o.map !== 'none') {
        if (!e) {
          return compileWithMap();
        }
      } else {
        if (!e) {
          return compile();
        }
      }
      require('child_process').exec("mkdir " + [!/^win/.test(process.platform) ? '-p' : void 8] + " " + dir, compile);
    });
  }
  function outputFilename(filename, json){
    return path.basename(filename).replace(/(?:(\.\w+)?\.\w+)?$/, function(){
      return arguments[1] || (json ? '.json' : '.js');
    });
  }
  function printTokens(tokens){
    var lines, i$, len$, ref$, tag, val, lno, l;
    lines = [];
    for (i$ = 0, len$ = tokens.length; i$ < len$; ++i$) {
      ref$ = tokens[i$], tag = ref$[0], val = ref$[1], lno = ref$[2];
      ((ref$ = lines[lno]) != null
        ? ref$
        : lines[lno] = []).push(tag.toLowerCase() === val
        ? tag
        : tag + ":" + val);
    }
    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
      l = lines[i$];
      say(l ? l.join(' ').replace(/\n/g, '\\n') : '');
    }
  }
  function repl(){
    var MAXHISTORYSIZE, historyFile, code, cont, rl, reset, _ttyWrite, prompt, that, vm, replCtx, server, ref$;
    MAXHISTORYSIZE = 500;
    historyFile = path.join(process.env.HOME, '/.lsc_history');
    code = repl.infunc ? '  ' : '';
    cont = 0;
    rl = require('readline').createInterface(process.stdin, process.stdout);
    reset = function(){
      rl.line = code = '';
      rl.prompt();
      repl.inheredoc = false;
    };
    (_ttyWrite = rl._ttyWrite, rl)._ttyWrite = function(char){
      if (char === '\n' || char === '>') {
        cont += 1;
      } else {
        cont = 0;
      }
      return _ttyWrite.apply(this, arguments);
    };
    prompt = 'ls';
    if (that = repeatString$('b', !!o.bare) + repeatString$('c', !!o.compile)) {
      prompt += " -" + that;
    }
    try {
      rl.history = lines(fs.readFileSync(historyFile, 'utf-8').trim());
    } catch (e$) {}
    if (LiveScript != null) {
      LiveScript.history = rl.history;
    }
    if (!o.compile) {
      module.paths = module.constructor._nodeModulePaths(module.filename = process.cwd() + '/repl');
      vm = require('vm');
      if (o.prelude) {
        import$(global, prelude);
      }
      replCtx = {};
      import$(replCtx, global);
      replCtx.module = module;
      replCtx.exports = exports;
      replCtx.require = require;
      replCtx.LiveScript = LiveScript;
      replCtx.path = path;
      replCtx.fs = fs;
      replCtx.util = util;
      replCtx.say = say;
      replCtx.warn = warn;
      replCtx.die = die;
      replCtx.p = p;
      replCtx.pp = pp;
      replCtx.ppp = ppp;
      server = (ref$ = clone$(require('repl').REPLServer.prototype), ref$.context = replCtx, ref$.commands = [], ref$.useGlobal = true, ref$.useColors = process.env.NODE_DISABLE_COLORS, ref$.eval = function(code, ctx, arg$, cb){
        var res, e;
        try {
          res = vm.runInNewContext(code, ctx, 'repl');
        } catch (e$) {
          e = e$;
        }
        cb(e, res);
      }, ref$);
      rl.completer = function(line, cb){
        var contextVars, matches;
        contextVars = map(dasherizeVars, keys(server.context));
        matches = filter(startsWith(line), contextVars);
        return cb(null, [matches.length ? matches : contextVars, line]);
      };
    }
    rl.on('SIGCONT', rl.prompt);
    rl.on('SIGINT', function(){
      if (this.line || code) {
        say('');
        reset();
      } else {
        this.close();
      }
    });
    rl.on('close', function(){
      say('');
      return process.exit();
    });
    rl.on('line', function(it){
      var isheredoc, ops, x, e;
      if (it.match(/^$/)) {
        repl.infunc = false;
      }
      if (it.match(/(\=|\~>|->|do|import|switch)\s*$/) || (it.match(/^!?(function|class|if|unless) /) && !it.match(/ then /))) {
        repl.infunc = true;
      }
      if (((0 < cont && cont < 3) || repl.infunc) && !repl.inheredoc) {
        code += it + '\n';
        this.output.write(repeatString$('.', prompt.length) + '. ');
        return;
      } else {
        isheredoc = it.match(/(\'\'\'|\"\"\")/g);
        if (isheredoc && isheredoc.length % 2 === 1) {
          repl.inheredoc = !repl.inheredoc;
        }
        if (repl.inheredoc) {
          code += it + '\n';
          rl.output.write(repeatString$('.', prompt.length) + '" ');
          return;
        }
      }
      repl.inheredoc = false;
      if (!(code += it)) {
        return reset();
      }
      try {
        if (o.compile) {
          say(LiveScript.compile(code, {
            bare: o.bare
          }));
        } else {
          ops = {
            'eval': 'eval',
            bare: true,
            saveScope: LiveScript
          };
          if (code.match(/^\s*!?function/)) {
            ops = {
              bare: true
            };
          }
          x = vm.runInNewContext(LiveScript.compile(code, ops), replCtx, 'repl');
          if (x != null) {
            replCtx._ = x;
          }
          pp(x);
          if (typeof x === 'function') {
            say(x);
          }
        }
      } catch (e$) {
        e = e$;
        say(e);
      }
      reset();
    });
    process.on('uncaughtException', function(it){
      say("\n" + ((it != null ? it.stack : void 8) || it));
    });
    process.on('exit', function(){
      if (code && rl.output.isTTY) {
        rl._ttyWrite('\r');
      }
      if (fileExists(historyFile)) {
        fs.writeFileSync(historyFile, compose$(take(MAXHISTORYSIZE), unlines)(rl.history));
      }
    });
    rl.setPrompt(prompt + "> ");
    rl.prompt();
  }
  function forkNode(){
    var ref$, args, lsArgs, ref1$, nodeArgs, this$ = this;
    ref$ = process.argv, args = slice$.call(ref$, 1);
    ref$ = breakList((function(it){
      return it === '--nodejs' || it === '-n';
    }), args), lsArgs = ref$[0], ref1$ = ref$[1], nodeArgs = slice$.call(ref1$, 1);
    require('child_process').spawn(process.execPath, nodeArgs.concat(lsArgs), {
      cwd: process.cwd(),
      stdio: 'inherit'
    });
  }
});
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
function compose$() {
  var functions = arguments;
  return function() {
    var i, result;
    result = functions[0].apply(this, arguments);
    for (i = 1; i < functions.length; ++i) {
      result = functions[i](result);
    }
    return result;
  };
}