/**
 * Writeout a file.
 * @function writeout
 * @param {string} filename - Filename to write.
 * @param {string} content - String content to write.
 * @param {object} [options] - Optional settings.
 * @param {boolean} [options.mkdirp=false] - Make parent directories.
 * @param {boolean} [options.skipIfIdentical=false] - Skip to write if existing content is identical.
 * @param {string} [options.mode='644'] - File permission.
 * @param {boolean} [options.force=false] - Force to write even if existing file is readonly.
 * @returns {Promise}
 */

'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var co = require('co');
var fs = require('fs');
var path = require('path');
var argx = require('argx');
var mkdirp = require('mkdirp');
var filedel = require('filedel');
var _hasDuplicate = require('./_has_duplicate');

/** @lends writeout */
function writeout(filename, content) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  if (argx(arguments).pop('function')) {
    throw new Error('[writeout] Callback is no more supported. Use promise interface instead.');
  }

  var needsMkdirp = !!options.mkdirp;
  var skipIfIdentical = !!options.skipIfIdentical;
  var force = !!options.force;
  var mode = options.mode || '644';

  var result = { filename: filename };

  return co(_regenerator2.default.mark(function _callee() {
    var skip;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!needsMkdirp) {
              _context.next = 3;
              break;
            }

            _context.next = 3;
            return new _promise2.default(function (resolve, reject) {
              return mkdirp(path.dirname(filename), function (err) {
                return err ? reject(err) : resolve();
              });
            });

          case 3:
            if (!skipIfIdentical) {
              _context.next = 10;
              break;
            }

            _context.next = 6;
            return _hasDuplicate(filename, content);

          case 6:
            skip = _context.sent;

            if (!skip) {
              _context.next = 10;
              break;
            }

            result.skipped = true;
            return _context.abrupt('return', result);

          case 10:
            if (!force) {
              _context.next = 13;
              break;
            }

            _context.next = 13;
            return filedel(filename, { force: true });

          case 13:
            _context.next = 15;
            return new _promise2.default(function (resolve, reject) {
              return fs.writeFile(filename, content, {
                mode: mode
              }, function (err) {
                return err ? reject(err) : resolve();
              });
            });

          case 15:

            result.skipped = false;

            // Wait for flush
            _context.next = 18;
            return new _promise2.default(function (resolve) {
              return process.nextTick(function () {
                return resolve();
              });
            });

          case 18:
            return _context.abrupt('return', result);

          case 19:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
}

module.exports = writeout;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndyaXRlb3V0LmpzIl0sIm5hbWVzIjpbImNvIiwicmVxdWlyZSIsImZzIiwicGF0aCIsImFyZ3giLCJta2RpcnAiLCJmaWxlZGVsIiwiX2hhc0R1cGxpY2F0ZSIsIndyaXRlb3V0IiwiZmlsZW5hbWUiLCJjb250ZW50Iiwib3B0aW9ucyIsImFyZ3VtZW50cyIsInBvcCIsIkVycm9yIiwibmVlZHNNa2RpcnAiLCJza2lwSWZJZGVudGljYWwiLCJmb3JjZSIsIm1vZGUiLCJyZXN1bHQiLCJyZXNvbHZlIiwicmVqZWN0IiwiZGlybmFtZSIsImVyciIsInNraXAiLCJza2lwcGVkIiwid3JpdGVGaWxlIiwicHJvY2VzcyIsIm5leHRUaWNrIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUEsS0FBS0MsUUFBUSxJQUFSLENBQVg7QUFDQSxJQUFNQyxLQUFLRCxRQUFRLElBQVIsQ0FBWDtBQUNBLElBQU1FLE9BQU9GLFFBQVEsTUFBUixDQUFiO0FBQ0EsSUFBTUcsT0FBT0gsUUFBUSxNQUFSLENBQWI7QUFDQSxJQUFNSSxTQUFTSixRQUFRLFFBQVIsQ0FBZjtBQUNBLElBQU1LLFVBQVVMLFFBQVEsU0FBUixDQUFoQjtBQUNBLElBQU1NLGdCQUFnQk4sUUFBUSxrQkFBUixDQUF0Qjs7QUFFQTtBQUNBLFNBQVNPLFFBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCQyxPQUE3QixFQUFvRDtBQUFBLE1BQWRDLE9BQWMseURBQUosRUFBSTs7QUFDbEQsTUFBSVAsS0FBS1EsU0FBTCxFQUFnQkMsR0FBaEIsQ0FBb0IsVUFBcEIsQ0FBSixFQUFxQztBQUNuQyxVQUFNLElBQUlDLEtBQUosQ0FBVSwwRUFBVixDQUFOO0FBQ0Q7O0FBRUQsTUFBSUMsY0FBYyxDQUFDLENBQUNKLFFBQVFOLE1BQTVCO0FBQ0EsTUFBSVcsa0JBQWtCLENBQUMsQ0FBQ0wsUUFBUUssZUFBaEM7QUFDQSxNQUFJQyxRQUFRLENBQUMsQ0FBQ04sUUFBUU0sS0FBdEI7QUFDQSxNQUFJQyxPQUFPUCxRQUFRTyxJQUFSLElBQWdCLEtBQTNCOztBQUVBLE1BQUlDLFNBQVMsRUFBRVYsa0JBQUYsRUFBYjs7QUFFQSxTQUFPVCw4QkFBRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFDSmUsV0FESTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQUVBLHNCQUFZLFVBQUNLLE9BQUQsRUFBVUMsTUFBVjtBQUFBLHFCQUNoQmhCLE9BQU9GLEtBQUttQixPQUFMLENBQWFiLFFBQWIsQ0FBUCxFQUErQixVQUFDYyxHQUFEO0FBQUEsdUJBQVNBLE1BQU1GLE9BQU9FLEdBQVAsQ0FBTixHQUFvQkgsU0FBN0I7QUFBQSxlQUEvQixDQURnQjtBQUFBLGFBQVosQ0FGQTs7QUFBQTtBQUFBLGlCQU9KSixlQVBJO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsbUJBUVdULGNBQWNFLFFBQWQsRUFBd0JDLE9BQXhCLENBUlg7O0FBQUE7QUFRRmMsZ0JBUkU7O0FBQUEsaUJBU0ZBLElBVEU7QUFBQTtBQUFBO0FBQUE7O0FBVUpMLG1CQUFPTSxPQUFQLEdBQWlCLElBQWpCO0FBVkksNkNBV0dOLE1BWEg7O0FBQUE7QUFBQSxpQkFlSkYsS0FmSTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQWdCQVgsUUFBUUcsUUFBUixFQUFrQixFQUFFUSxPQUFPLElBQVQsRUFBbEIsQ0FoQkE7O0FBQUE7QUFBQTtBQUFBLG1CQW1CRixzQkFBWSxVQUFDRyxPQUFELEVBQVVDLE1BQVY7QUFBQSxxQkFDaEJuQixHQUFHd0IsU0FBSCxDQUFhakIsUUFBYixFQUF1QkMsT0FBdkIsRUFBZ0M7QUFDOUJRLHNCQUFNQTtBQUR3QixlQUFoQyxFQUVHLFVBQUNLLEdBQUQ7QUFBQSx1QkFBU0EsTUFBTUYsT0FBT0UsR0FBUCxDQUFOLEdBQW9CSCxTQUE3QjtBQUFBLGVBRkgsQ0FEZ0I7QUFBQSxhQUFaLENBbkJFOztBQUFBOztBQXlCUkQsbUJBQU9NLE9BQVAsR0FBaUIsS0FBakI7O0FBRUE7QUEzQlE7QUFBQSxtQkE0QkYsc0JBQVksVUFBQ0wsT0FBRDtBQUFBLHFCQUNoQk8sUUFBUUMsUUFBUixDQUFpQjtBQUFBLHVCQUFNUixTQUFOO0FBQUEsZUFBakIsQ0FEZ0I7QUFBQSxhQUFaLENBNUJFOztBQUFBO0FBQUEsNkNBZ0NERCxNQWhDQzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUFILEVBQVA7QUFrQ0Q7O0FBRURVLE9BQU9DLE9BQVAsR0FBaUJ0QixRQUFqQiIsImZpbGUiOiJ3cml0ZW91dC5qcyIsInNvdXJjZVJvb3QiOiJsaWIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFdyaXRlb3V0IGEgZmlsZS5cbiAqIEBmdW5jdGlvbiB3cml0ZW91dFxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIC0gRmlsZW5hbWUgdG8gd3JpdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIFN0cmluZyBjb250ZW50IHRvIHdyaXRlLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5ta2RpcnA9ZmFsc2VdIC0gTWFrZSBwYXJlbnQgZGlyZWN0b3JpZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBJZklkZW50aWNhbD1mYWxzZV0gLSBTa2lwIHRvIHdyaXRlIGlmIGV4aXN0aW5nIGNvbnRlbnQgaXMgaWRlbnRpY2FsLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1vZGU9JzY0NCddIC0gRmlsZSBwZXJtaXNzaW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb3JjZT1mYWxzZV0gLSBGb3JjZSB0byB3cml0ZSBldmVuIGlmIGV4aXN0aW5nIGZpbGUgaXMgcmVhZG9ubHkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgY28gPSByZXF1aXJlKCdjbycpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGFyZ3ggPSByZXF1aXJlKCdhcmd4JylcbmNvbnN0IG1rZGlycCA9IHJlcXVpcmUoJ21rZGlycCcpXG5jb25zdCBmaWxlZGVsID0gcmVxdWlyZSgnZmlsZWRlbCcpXG5jb25zdCBfaGFzRHVwbGljYXRlID0gcmVxdWlyZSgnLi9faGFzX2R1cGxpY2F0ZScpXG5cbi8qKiBAbGVuZHMgd3JpdGVvdXQgKi9cbmZ1bmN0aW9uIHdyaXRlb3V0IChmaWxlbmFtZSwgY29udGVudCwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmIChhcmd4KGFyZ3VtZW50cykucG9wKCdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbd3JpdGVvdXRdIENhbGxiYWNrIGlzIG5vIG1vcmUgc3VwcG9ydGVkLiBVc2UgcHJvbWlzZSBpbnRlcmZhY2UgaW5zdGVhZC4nKVxuICB9XG5cbiAgbGV0IG5lZWRzTWtkaXJwID0gISFvcHRpb25zLm1rZGlycFxuICBsZXQgc2tpcElmSWRlbnRpY2FsID0gISFvcHRpb25zLnNraXBJZklkZW50aWNhbFxuICBsZXQgZm9yY2UgPSAhIW9wdGlvbnMuZm9yY2VcbiAgbGV0IG1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJzY0NCdcblxuICBsZXQgcmVzdWx0ID0geyBmaWxlbmFtZSB9XG5cbiAgcmV0dXJuIGNvKGZ1bmN0aW9uICogKCkge1xuICAgIGlmIChuZWVkc01rZGlycCkge1xuICAgICAgeWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAgbWtkaXJwKHBhdGguZGlybmFtZShmaWxlbmFtZSksIChlcnIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpKVxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChza2lwSWZJZGVudGljYWwpIHtcbiAgICAgIGxldCBza2lwID0geWllbGQgX2hhc0R1cGxpY2F0ZShmaWxlbmFtZSwgY29udGVudClcbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIHJlc3VsdC5za2lwcGVkID0gdHJ1ZVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICB5aWVsZCBmaWxlZGVsKGZpbGVuYW1lLCB7IGZvcmNlOiB0cnVlIH0pXG4gICAgfVxuXG4gICAgeWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgIGZzLndyaXRlRmlsZShmaWxlbmFtZSwgY29udGVudCwge1xuICAgICAgICBtb2RlOiBtb2RlXG4gICAgICB9LCAoZXJyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKSlcbiAgICApXG5cbiAgICByZXN1bHQuc2tpcHBlZCA9IGZhbHNlXG5cbiAgICAvLyBXYWl0IGZvciBmbHVzaFxuICAgIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PlxuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiByZXNvbHZlKCkpXG4gICAgKVxuICAgIFxuICAgIHJldHVybiByZXN1bHRcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cml0ZW91dFxuIl19