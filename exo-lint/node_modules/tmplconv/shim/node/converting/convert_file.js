/**
 * Convert a file.
 * @function convertFile
 * @param {string} src - Source file path.
 * @param {string} dest - Destination file path.
 * @param {object} [options] - Optional settings.
 * @param {object} [options.rule={}] - Convert map.
 * @param {string} [options.mode='644'] - File mode to generate.
 * @param {boolean} [options.once=false] - Write only first time. Skip if already exists.
 * @returns {Promise}
 *
 */

'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var co = require('co');
var argx = require('argx');
var writeout = require('writeout');

var _require = require('asfs');

var existsAsync = _require.existsAsync;
var readFileAsync = _require.readFileAsync;

var convertString = require('./convert_string');

/** @lends convertFile */
function convertFile(src, dest, options) {
  var args = argx(arguments);
  options = args.pop('object');
  src = args.shift('string');
  dest = args.shift('string');

  var rule = options.rule || {};
  var mode = options.mode || '644';
  var once = !!options.once;

  return co(_regenerator2.default.mark(function _callee() {
    var exists, skip, content;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return existsAsync(dest);

          case 2:
            exists = _context.sent;
            skip = exists && once;

            if (!skip) {
              _context.next = 6;
              break;
            }

            return _context.abrupt('return');

          case 6:
            _context.next = 8;
            return readFileAsync(src);

          case 8:
            content = _context.sent;

            content = convertString(String(content), rule);
            _context.next = 12;
            return writeout(dest, content, {
              mkdirp: true,
              force: true,
              mode: mode
            });

          case 12:
            return _context.abrupt('return', _context.sent);

          case 13:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
}

module.exports = convertFile;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbnZlcnRfZmlsZS5qcyJdLCJuYW1lcyI6WyJjbyIsInJlcXVpcmUiLCJhcmd4Iiwid3JpdGVvdXQiLCJleGlzdHNBc3luYyIsInJlYWRGaWxlQXN5bmMiLCJjb252ZXJ0U3RyaW5nIiwiY29udmVydEZpbGUiLCJzcmMiLCJkZXN0Iiwib3B0aW9ucyIsImFyZ3MiLCJhcmd1bWVudHMiLCJwb3AiLCJzaGlmdCIsInJ1bGUiLCJtb2RlIiwib25jZSIsImV4aXN0cyIsInNraXAiLCJjb250ZW50IiwiU3RyaW5nIiwibWtkaXJwIiwiZm9yY2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7OztBQWFBOzs7Ozs7OztBQUVBLElBQU1BLEtBQUtDLFFBQVEsSUFBUixDQUFYO0FBQ0EsSUFBTUMsT0FBT0QsUUFBUSxNQUFSLENBQWI7QUFDQSxJQUFNRSxXQUFXRixRQUFRLFVBQVIsQ0FBakI7O2VBQ3VDQSxRQUFRLE1BQVIsQzs7SUFBL0JHLFcsWUFBQUEsVztJQUFhQyxhLFlBQUFBLGE7O0FBQ3JCLElBQU1DLGdCQUFnQkwsUUFBUSxrQkFBUixDQUF0Qjs7QUFFQTtBQUNBLFNBQVNNLFdBQVQsQ0FBc0JDLEdBQXRCLEVBQTJCQyxJQUEzQixFQUFpQ0MsT0FBakMsRUFBMEM7QUFDeEMsTUFBSUMsT0FBT1QsS0FBS1UsU0FBTCxDQUFYO0FBQ0FGLFlBQVVDLEtBQUtFLEdBQUwsQ0FBUyxRQUFULENBQVY7QUFDQUwsUUFBTUcsS0FBS0csS0FBTCxDQUFXLFFBQVgsQ0FBTjtBQUNBTCxTQUFPRSxLQUFLRyxLQUFMLENBQVcsUUFBWCxDQUFQOztBQUVBLE1BQUlDLE9BQU9MLFFBQVFLLElBQVIsSUFBZ0IsRUFBM0I7QUFDQSxNQUFJQyxPQUFPTixRQUFRTSxJQUFSLElBQWdCLEtBQTNCO0FBQ0EsTUFBSUMsT0FBTyxDQUFDLENBQUNQLFFBQVFPLElBQXJCOztBQUVBLFNBQU9qQiw4QkFBRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUNXSSxZQUFZSyxJQUFaLENBRFg7O0FBQUE7QUFDSlMsa0JBREk7QUFFSkMsZ0JBRkksR0FFR0QsVUFBVUQsSUFGYjs7QUFBQSxpQkFHSkUsSUFISTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUEsbUJBTVlkLGNBQWNHLEdBQWQsQ0FOWjs7QUFBQTtBQU1KWSxtQkFOSTs7QUFPUkEsc0JBQVVkLGNBQWNlLE9BQU9ELE9BQVAsQ0FBZCxFQUErQkwsSUFBL0IsQ0FBVjtBQVBRO0FBQUEsbUJBUUtaLFNBQVNNLElBQVQsRUFBZVcsT0FBZixFQUF3QjtBQUNuQ0Usc0JBQVEsSUFEMkI7QUFFbkNDLHFCQUFPLElBRjRCO0FBR25DUDtBQUhtQyxhQUF4QixDQVJMOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBSCxFQUFQO0FBY0Q7O0FBRURRLE9BQU9DLE9BQVAsR0FBaUJsQixXQUFqQiIsImZpbGUiOiJjb252ZXJ0X2ZpbGUuanMiLCJzb3VyY2VSb290IjoibGliIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb252ZXJ0IGEgZmlsZS5cbiAqIEBmdW5jdGlvbiBjb252ZXJ0RmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyAtIFNvdXJjZSBmaWxlIHBhdGguXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdCAtIERlc3RpbmF0aW9uIGZpbGUgcGF0aC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5ydWxlPXt9XSAtIENvbnZlcnQgbWFwLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1vZGU9JzY0NCddIC0gRmlsZSBtb2RlIHRvIGdlbmVyYXRlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSAtIFdyaXRlIG9ubHkgZmlyc3QgdGltZS4gU2tpcCBpZiBhbHJlYWR5IGV4aXN0cy5cbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgY28gPSByZXF1aXJlKCdjbycpXG5jb25zdCBhcmd4ID0gcmVxdWlyZSgnYXJneCcpXG5jb25zdCB3cml0ZW91dCA9IHJlcXVpcmUoJ3dyaXRlb3V0JylcbmNvbnN0IHsgZXhpc3RzQXN5bmMsIHJlYWRGaWxlQXN5bmMgfSA9IHJlcXVpcmUoJ2FzZnMnKVxuY29uc3QgY29udmVydFN0cmluZyA9IHJlcXVpcmUoJy4vY29udmVydF9zdHJpbmcnKVxuXG4vKiogQGxlbmRzIGNvbnZlcnRGaWxlICovXG5mdW5jdGlvbiBjb252ZXJ0RmlsZSAoc3JjLCBkZXN0LCBvcHRpb25zKSB7XG4gIGxldCBhcmdzID0gYXJneChhcmd1bWVudHMpXG4gIG9wdGlvbnMgPSBhcmdzLnBvcCgnb2JqZWN0JylcbiAgc3JjID0gYXJncy5zaGlmdCgnc3RyaW5nJylcbiAgZGVzdCA9IGFyZ3Muc2hpZnQoJ3N0cmluZycpXG5cbiAgbGV0IHJ1bGUgPSBvcHRpb25zLnJ1bGUgfHwge31cbiAgbGV0IG1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJzY0NCdcbiAgbGV0IG9uY2UgPSAhIW9wdGlvbnMub25jZTtcblxuICByZXR1cm4gY28oZnVuY3Rpb24gKiAoKSB7XG4gICAgbGV0IGV4aXN0cyA9IHlpZWxkIGV4aXN0c0FzeW5jKGRlc3QpXG4gICAgbGV0IHNraXAgPSBleGlzdHMgJiYgb25jZVxuICAgIGlmIChza2lwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSB5aWVsZCByZWFkRmlsZUFzeW5jKHNyYylcbiAgICBjb250ZW50ID0gY29udmVydFN0cmluZyhTdHJpbmcoY29udGVudCksIHJ1bGUpXG4gICAgcmV0dXJuIHlpZWxkIHdyaXRlb3V0KGRlc3QsIGNvbnRlbnQsIHtcbiAgICAgIG1rZGlycDogdHJ1ZSxcbiAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgbW9kZVxuICAgIH0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydEZpbGVcbiJdfQ==