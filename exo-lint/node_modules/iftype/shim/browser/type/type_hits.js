/**
 * Detect if type hits.
 * @memberof module:iftype/lib/type
 * @function typeHits
 * @param {*} value - Value to check with.
 * @param {string|object|string[]|object[]} type - Type to check with.
 * @returns {boolean} - Hit or not.
 * @private
 */
'use strict';

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var parseType = require('./parse_type');

/** @lends typeHits */
function typeHits(value, type) {
  var isEmpty = typeof value === 'undefined' || value === null;
  if (isEmpty) {
    return false;
  }
  var s = this;
  var isMultiple = Array.isArray(type);
  if (isMultiple) {
    return typeHits.anyOf(value, type);
  }
  type = parseType(type);
  var isArrayType = type === 'array';
  if (isArrayType) {
    return Array.isArray(value);
  }
  switch (typeof type === 'undefined' ? 'undefined' : (0, _typeof3.default)(type)) {
    case 'string':
      if (/\|/.test(type)) {
        return typeHits.anyOf(value, type.split(/\|/g));
      }
      return (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === type;
    case 'function':
      return value instanceof type;
    case 'object':
      return !!(type && type.isPrototypeOf) && type.isPrototypeOf(value);
    default:
      return false;
  }
}

/**
 * Detect if any of type hits.
 * @param {*} value - Value to check with.
 * @param {string[]|object[]} types - types to check.
 * @returns {boolean} - Hit or not.
 * @private
 */
typeHits.anyOf = function anyOfTypeHits(value, types) {
  for (var i = 0, len = types.length; i < len; i++) {
    var type = types[i];
    var hit = typeHits(value, type);
    if (hit) {
      return true;
    }
  }
  return false;
};

module.exports = typeHits;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInR5cGVfaGl0cy5qcyJdLCJuYW1lcyI6WyJwYXJzZVR5cGUiLCJyZXF1aXJlIiwidHlwZUhpdHMiLCJ2YWx1ZSIsInR5cGUiLCJpc0VtcHR5IiwicyIsImlzTXVsdGlwbGUiLCJBcnJheSIsImlzQXJyYXkiLCJhbnlPZiIsImlzQXJyYXlUeXBlIiwidGVzdCIsInNwbGl0IiwiaXNQcm90b3R5cGVPZiIsImFueU9mVHlwZUhpdHMiLCJ0eXBlcyIsImkiLCJsZW4iLCJsZW5ndGgiLCJoaXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7O0FBRUEsSUFBTUEsWUFBWUMsUUFBUSxjQUFSLENBQWxCOztBQUVBO0FBQ0EsU0FBU0MsUUFBVCxDQUFtQkMsS0FBbkIsRUFBMEJDLElBQTFCLEVBQWdDO0FBQzlCLE1BQUlDLFVBQVcsT0FBT0YsS0FBUCxLQUFpQixXQUFsQixJQUFtQ0EsVUFBVSxJQUEzRDtBQUNBLE1BQUlFLE9BQUosRUFBYTtBQUNYLFdBQU8sS0FBUDtBQUNEO0FBQ0QsTUFBSUMsSUFBSSxJQUFSO0FBQ0EsTUFBSUMsYUFBYUMsTUFBTUMsT0FBTixDQUFjTCxJQUFkLENBQWpCO0FBQ0EsTUFBSUcsVUFBSixFQUFnQjtBQUNkLFdBQU9MLFNBQVNRLEtBQVQsQ0FBZVAsS0FBZixFQUFzQkMsSUFBdEIsQ0FBUDtBQUNEO0FBQ0RBLFNBQU9KLFVBQVVJLElBQVYsQ0FBUDtBQUNBLE1BQUlPLGNBQWVQLFNBQVMsT0FBNUI7QUFDQSxNQUFJTyxXQUFKLEVBQWlCO0FBQ2YsV0FBT0gsTUFBTUMsT0FBTixDQUFjTixLQUFkLENBQVA7QUFDRDtBQUNELGlCQUFlQyxJQUFmLHVEQUFlQSxJQUFmO0FBQ0UsU0FBSyxRQUFMO0FBQ0UsVUFBSSxLQUFLUSxJQUFMLENBQVVSLElBQVYsQ0FBSixFQUFxQjtBQUNuQixlQUFPRixTQUFTUSxLQUFULENBQWVQLEtBQWYsRUFBc0JDLEtBQUtTLEtBQUwsQ0FBVyxLQUFYLENBQXRCLENBQVA7QUFDRDtBQUNELGFBQU8sUUFBT1YsS0FBUCx1REFBT0EsS0FBUCxPQUFpQkMsSUFBeEI7QUFDRixTQUFLLFVBQUw7QUFDRSxhQUFPRCxpQkFBa0JDLElBQXpCO0FBQ0YsU0FBSyxRQUFMO0FBQ0UsYUFBTyxDQUFDLEVBQUVBLFFBQVFBLEtBQUtVLGFBQWYsQ0FBRCxJQUFrQ1YsS0FBS1UsYUFBTCxDQUFtQlgsS0FBbkIsQ0FBekM7QUFDRjtBQUNFLGFBQU8sS0FBUDtBQVhKO0FBYUQ7O0FBRUQ7Ozs7Ozs7QUFPQUQsU0FBU1EsS0FBVCxHQUFpQixTQUFTSyxhQUFULENBQXdCWixLQUF4QixFQUErQmEsS0FBL0IsRUFBc0M7QUFDckQsT0FBSyxJQUFJQyxJQUFJLENBQVIsRUFBV0MsTUFBTUYsTUFBTUcsTUFBNUIsRUFBb0NGLElBQUlDLEdBQXhDLEVBQTZDRCxHQUE3QyxFQUFrRDtBQUNoRCxRQUFJYixPQUFPWSxNQUFPQyxDQUFQLENBQVg7QUFDQSxRQUFJRyxNQUFNbEIsU0FBU0MsS0FBVCxFQUFnQkMsSUFBaEIsQ0FBVjtBQUNBLFFBQUlnQixHQUFKLEVBQVM7QUFDUCxhQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBTyxLQUFQO0FBQ0QsQ0FURDs7QUFXQUMsT0FBT0MsT0FBUCxHQUFpQnBCLFFBQWpCIiwiZmlsZSI6InR5cGVfaGl0cy5qcyIsInNvdXJjZVJvb3QiOiJsaWIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERldGVjdCBpZiB0eXBlIGhpdHMuXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmlmdHlwZS9saWIvdHlwZVxuICogQGZ1bmN0aW9uIHR5cGVIaXRzXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgd2l0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdHxzdHJpbmdbXXxvYmplY3RbXX0gdHlwZSAtIFR5cGUgdG8gY2hlY2sgd2l0aC5cbiAqIEByZXR1cm5zIHtib29sZWFufSAtIEhpdCBvciBub3QuXG4gKiBAcHJpdmF0ZVxuICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgcGFyc2VUeXBlID0gcmVxdWlyZSgnLi9wYXJzZV90eXBlJylcblxuLyoqIEBsZW5kcyB0eXBlSGl0cyAqL1xuZnVuY3Rpb24gdHlwZUhpdHMgKHZhbHVlLCB0eXBlKSB7XG4gIGxldCBpc0VtcHR5ID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHx8ICh2YWx1ZSA9PT0gbnVsbClcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBsZXQgcyA9IHRoaXNcbiAgbGV0IGlzTXVsdGlwbGUgPSBBcnJheS5pc0FycmF5KHR5cGUpXG4gIGlmIChpc011bHRpcGxlKSB7XG4gICAgcmV0dXJuIHR5cGVIaXRzLmFueU9mKHZhbHVlLCB0eXBlKVxuICB9XG4gIHR5cGUgPSBwYXJzZVR5cGUodHlwZSlcbiAgbGV0IGlzQXJyYXlUeXBlID0gKHR5cGUgPT09ICdhcnJheScpXG4gIGlmIChpc0FycmF5VHlwZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICB9XG4gIHN3aXRjaCAodHlwZW9mIHR5cGUpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgaWYgKC9cXHwvLnRlc3QodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVIaXRzLmFueU9mKHZhbHVlLCB0eXBlLnNwbGl0KC9cXHwvZykpXG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSB0eXBlXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgKHR5cGUpXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiAhISh0eXBlICYmIHR5cGUuaXNQcm90b3R5cGVPZikgJiYgdHlwZS5pc1Byb3RvdHlwZU9mKHZhbHVlKVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIERldGVjdCBpZiBhbnkgb2YgdHlwZSBoaXRzLlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIHdpdGguXG4gKiBAcGFyYW0ge3N0cmluZ1tdfG9iamVjdFtdfSB0eXBlcyAtIHR5cGVzIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gSGl0IG9yIG5vdC5cbiAqIEBwcml2YXRlXG4gKi9cbnR5cGVIaXRzLmFueU9mID0gZnVuY3Rpb24gYW55T2ZUeXBlSGl0cyAodmFsdWUsIHR5cGVzKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCB0eXBlID0gdHlwZXNbIGkgXVxuICAgIGxldCBoaXQgPSB0eXBlSGl0cyh2YWx1ZSwgdHlwZSlcbiAgICBpZiAoaGl0KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlSGl0c1xuIl19