/**
 * Parse arguments.
 * @constructor Argx
 * @param {Arguments} args - Function arguments
 */

'use strict';

var iftype = require('iftype');
var isNumber = require('./type/is_number');

/** @lends constructor */
function Argx(args) {
  var s = this;
  s.values = Array.prototype.slice.call(args, 0);
}

Argx.prototype = {
  /**
   * Splice argument values.
   * @param {number} start - Where to start
   * @param {number} [howmany=1] - Number of value to get.
   * @param {string} [type] - Type restriction.
   */
  splice: function splice(start, howmany, type) {
    var s = this;

    if (typeof arguments[1] !== 'number') {
      if (isNumber(arguments[1])) {
        howmany = Number(arguments[1]);
      } else {
        type = arguments[1];
        howmany = 1;
      }
    }
    howmany = howmany || 1;
    if (start < 0) {
      start += s.values.length;
    }
    var result = void 0;
    var hitCount = 0;
    for (var i = start + howmany - 1; i >= start; i--) {
      var skipByType = type && !iftype(s.values[i]).is(type);
      if (skipByType) {
        break;
      }
      var spliced = s.values.splice(i, 1);
      if (!spliced.length) {
        break;
      }
      spliced = spliced[0];
      switch (hitCount) {
        case 0:
          result = spliced;
          break;
        case 1:
          result = [spliced, result];
          break;
        default:
          result.unshift(spliced);
          break;
      }
      hitCount += 1;
    }
    return result;
  },

  /**
   * Pop values
   * @param {number|string} [howmany=1] - Number of value to get.
   * @param {string|function} [type] - Type restriction. Could be a name of type or a constructor.
   * @returns {*} - Value. Array if multiple hits.
   * @example
   *  function doSomething() {
     *      let args = argx(arguments)
     *      args.pop()
     *      args.pop(2)
     *      args.pop('string')
     *      args.pop(MyCustomError)
     *  }
   */
  pop: function pop(howmany, type) {
    var s = this;
    var from = -Number(howmany);
    if (isNaN(from)) {
      from = -1;
    }
    return s.splice(from, howmany, type);
  },

  /**
   * Shift values
   * @param {number|string} [howmany=1] - Number of value to get.
   * @param {string} [type] - Type restriction. Could be a name of type or a constructor.
   * @returns {*} - Value. Array if multiple hits.
   * @example
   *  function doSomething() {
     *      let args = argx(arguments)
     *      args.shift()
     *      args.shift(2)
     *      args.shift('string')
     *      args.shift(MyCustomError)
     *  }
   */
  shift: function shift(howmany, type) {
    var s = this;
    return s.splice(0, howmany, type);
  },

  /**
   * Get all remain values.
   * @returns {Array}
   */
  remain: function remain() {
    var s = this;
    var values = s.values;
    s.values = [];
    return values;
  }
};

module.exports = Argx;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFyZ3guanMiXSwibmFtZXMiOlsiaWZ0eXBlIiwicmVxdWlyZSIsImlzTnVtYmVyIiwiQXJneCIsImFyZ3MiLCJzIiwidmFsdWVzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJzcGxpY2UiLCJzdGFydCIsImhvd21hbnkiLCJ0eXBlIiwiYXJndW1lbnRzIiwiTnVtYmVyIiwibGVuZ3RoIiwicmVzdWx0IiwiaGl0Q291bnQiLCJpIiwic2tpcEJ5VHlwZSIsImlzIiwic3BsaWNlZCIsInVuc2hpZnQiLCJwb3AiLCJmcm9tIiwiaXNOYU4iLCJzaGlmdCIsInJlbWFpbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFNQTs7QUFFQSxJQUFNQSxTQUFTQyxRQUFRLFFBQVIsQ0FBZjtBQUNBLElBQU1DLFdBQVdELFFBQVEsa0JBQVIsQ0FBakI7O0FBRUE7QUFDQSxTQUFTRSxJQUFULENBQWVDLElBQWYsRUFBcUI7QUFDbkIsTUFBTUMsSUFBSSxJQUFWO0FBQ0FBLElBQUVDLE1BQUYsR0FBV0MsTUFBTUMsU0FBTixDQUFnQkMsS0FBaEIsQ0FBc0JDLElBQXRCLENBQTJCTixJQUEzQixFQUFpQyxDQUFqQyxDQUFYO0FBQ0Q7O0FBRURELEtBQUtLLFNBQUwsR0FBaUI7QUFDZjs7Ozs7O0FBTUFHLFFBUGUsa0JBT1BDLEtBUE8sRUFPQUMsT0FQQSxFQU9TQyxJQVBULEVBT2U7QUFDNUIsUUFBTVQsSUFBSSxJQUFWOztBQUVBLFFBQUksT0FBT1UsVUFBVyxDQUFYLENBQVAsS0FBMEIsUUFBOUIsRUFBd0M7QUFDdEMsVUFBSWIsU0FBU2EsVUFBVyxDQUFYLENBQVQsQ0FBSixFQUE4QjtBQUM1QkYsa0JBQVVHLE9BQU9ELFVBQVcsQ0FBWCxDQUFQLENBQVY7QUFDRCxPQUZELE1BRU87QUFDTEQsZUFBT0MsVUFBVyxDQUFYLENBQVA7QUFDQUYsa0JBQVUsQ0FBVjtBQUNEO0FBQ0Y7QUFDREEsY0FBVUEsV0FBVyxDQUFyQjtBQUNBLFFBQUlELFFBQVEsQ0FBWixFQUFlO0FBQ2JBLGVBQVNQLEVBQUVDLE1BQUYsQ0FBU1csTUFBbEI7QUFDRDtBQUNELFFBQUlDLGVBQUo7QUFDQSxRQUFJQyxXQUFXLENBQWY7QUFDQSxTQUFLLElBQUlDLElBQUlSLFFBQVFDLE9BQVIsR0FBa0IsQ0FBL0IsRUFBa0NPLEtBQUtSLEtBQXZDLEVBQThDUSxHQUE5QyxFQUFtRDtBQUNqRCxVQUFJQyxhQUFhUCxRQUFRLENBQUNkLE9BQU9LLEVBQUVDLE1BQUYsQ0FBVWMsQ0FBVixDQUFQLEVBQXNCRSxFQUF0QixDQUF5QlIsSUFBekIsQ0FBMUI7QUFDQSxVQUFJTyxVQUFKLEVBQWdCO0FBQ2Q7QUFDRDtBQUNELFVBQUlFLFVBQVVsQixFQUFFQyxNQUFGLENBQVNLLE1BQVQsQ0FBZ0JTLENBQWhCLEVBQW1CLENBQW5CLENBQWQ7QUFDQSxVQUFJLENBQUNHLFFBQVFOLE1BQWIsRUFBcUI7QUFDbkI7QUFDRDtBQUNETSxnQkFBVUEsUUFBUyxDQUFULENBQVY7QUFDQSxjQUFRSixRQUFSO0FBQ0UsYUFBSyxDQUFMO0FBQ0VELG1CQUFTSyxPQUFUO0FBQ0E7QUFDRixhQUFLLENBQUw7QUFDRUwsbUJBQVMsQ0FBRUssT0FBRixFQUFXTCxNQUFYLENBQVQ7QUFDQTtBQUNGO0FBQ0VBLGlCQUFPTSxPQUFQLENBQWVELE9BQWY7QUFDQTtBQVRKO0FBV0FKLGtCQUFZLENBQVo7QUFDRDtBQUNELFdBQU9ELE1BQVA7QUFDRCxHQWhEYzs7QUFpRGY7Ozs7Ozs7Ozs7Ozs7O0FBY0FPLEtBL0RlLGVBK0RWWixPQS9EVSxFQStEREMsSUEvREMsRUErREs7QUFDbEIsUUFBTVQsSUFBSSxJQUFWO0FBQ0EsUUFBSXFCLE9BQU8sQ0FBQ1YsT0FBT0gsT0FBUCxDQUFaO0FBQ0EsUUFBSWMsTUFBTUQsSUFBTixDQUFKLEVBQWlCO0FBQ2ZBLGFBQU8sQ0FBQyxDQUFSO0FBQ0Q7QUFDRCxXQUFPckIsRUFBRU0sTUFBRixDQUFTZSxJQUFULEVBQWViLE9BQWYsRUFBd0JDLElBQXhCLENBQVA7QUFDRCxHQXRFYzs7QUF1RWY7Ozs7Ozs7Ozs7Ozs7O0FBY0FjLE9BckZlLGlCQXFGUmYsT0FyRlEsRUFxRkNDLElBckZELEVBcUZPO0FBQ3BCLFFBQU1ULElBQUksSUFBVjtBQUNBLFdBQU9BLEVBQUVNLE1BQUYsQ0FBUyxDQUFULEVBQVlFLE9BQVosRUFBcUJDLElBQXJCLENBQVA7QUFDRCxHQXhGYzs7QUF5RmY7Ozs7QUFJQWUsUUE3RmUsb0JBNkZMO0FBQ1IsUUFBTXhCLElBQUksSUFBVjtBQUNBLFFBQUlDLFNBQVNELEVBQUVDLE1BQWY7QUFDQUQsTUFBRUMsTUFBRixHQUFXLEVBQVg7QUFDQSxXQUFPQSxNQUFQO0FBQ0Q7QUFsR2MsQ0FBakI7O0FBcUdBd0IsT0FBT0MsT0FBUCxHQUFpQjVCLElBQWpCIiwiZmlsZSI6ImFyZ3guanMiLCJzb3VyY2VSb290IjoibGliIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQYXJzZSBhcmd1bWVudHMuXG4gKiBAY29uc3RydWN0b3IgQXJneFxuICogQHBhcmFtIHtBcmd1bWVudHN9IGFyZ3MgLSBGdW5jdGlvbiBhcmd1bWVudHNcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgaWZ0eXBlID0gcmVxdWlyZSgnaWZ0eXBlJylcbmNvbnN0IGlzTnVtYmVyID0gcmVxdWlyZSgnLi90eXBlL2lzX251bWJlcicpXG5cbi8qKiBAbGVuZHMgY29uc3RydWN0b3IgKi9cbmZ1bmN0aW9uIEFyZ3ggKGFyZ3MpIHtcbiAgY29uc3QgcyA9IHRoaXNcbiAgcy52YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAwKVxufVxuXG5Bcmd4LnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFNwbGljZSBhcmd1bWVudCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFdoZXJlIHRvIHN0YXJ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG93bWFueT0xXSAtIE51bWJlciBvZiB2YWx1ZSB0byBnZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gLSBUeXBlIHJlc3RyaWN0aW9uLlxuICAgKi9cbiAgc3BsaWNlIChzdGFydCwgaG93bWFueSwgdHlwZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzXG5cbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sgMSBdICE9PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTnVtYmVyKGFyZ3VtZW50c1sgMSBdKSkge1xuICAgICAgICBob3dtYW55ID0gTnVtYmVyKGFyZ3VtZW50c1sgMSBdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IGFyZ3VtZW50c1sgMSBdXG4gICAgICAgIGhvd21hbnkgPSAxXG4gICAgICB9XG4gICAgfVxuICAgIGhvd21hbnkgPSBob3dtYW55IHx8IDFcbiAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICBzdGFydCArPSBzLnZhbHVlcy5sZW5ndGhcbiAgICB9XG4gICAgbGV0IHJlc3VsdFxuICAgIGxldCBoaXRDb3VudCA9IDBcbiAgICBmb3IgKGxldCBpID0gc3RhcnQgKyBob3dtYW55IC0gMTsgaSA+PSBzdGFydDsgaS0tKSB7XG4gICAgICBsZXQgc2tpcEJ5VHlwZSA9IHR5cGUgJiYgIWlmdHlwZShzLnZhbHVlc1sgaSBdKS5pcyh0eXBlKVxuICAgICAgaWYgKHNraXBCeVR5cGUpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGxldCBzcGxpY2VkID0gcy52YWx1ZXMuc3BsaWNlKGksIDEpXG4gICAgICBpZiAoIXNwbGljZWQubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBzcGxpY2VkID0gc3BsaWNlZFsgMCBdXG4gICAgICBzd2l0Y2ggKGhpdENvdW50KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXN1bHQgPSBzcGxpY2VkXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlc3VsdCA9IFsgc3BsaWNlZCwgcmVzdWx0IF1cbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHNwbGljZWQpXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGhpdENvdW50ICs9IDFcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9LFxuICAvKipcbiAgICogUG9wIHZhbHVlc1xuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtob3dtYW55PTFdIC0gTnVtYmVyIG9mIHZhbHVlIHRvIGdldC5cbiAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IFt0eXBlXSAtIFR5cGUgcmVzdHJpY3Rpb24uIENvdWxkIGJlIGEgbmFtZSBvZiB0eXBlIG9yIGEgY29uc3RydWN0b3IuXG4gICAqIEByZXR1cm5zIHsqfSAtIFZhbHVlLiBBcnJheSBpZiBtdWx0aXBsZSBoaXRzLlxuICAgKiBAZXhhbXBsZVxuICAgKiAgZnVuY3Rpb24gZG9Tb21ldGhpbmcoKSB7XG4gICAgICogICAgICBsZXQgYXJncyA9IGFyZ3goYXJndW1lbnRzKVxuICAgICAqICAgICAgYXJncy5wb3AoKVxuICAgICAqICAgICAgYXJncy5wb3AoMilcbiAgICAgKiAgICAgIGFyZ3MucG9wKCdzdHJpbmcnKVxuICAgICAqICAgICAgYXJncy5wb3AoTXlDdXN0b21FcnJvcilcbiAgICAgKiAgfVxuICAgKi9cbiAgcG9wIChob3dtYW55LCB0eXBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXNcbiAgICBsZXQgZnJvbSA9IC1OdW1iZXIoaG93bWFueSlcbiAgICBpZiAoaXNOYU4oZnJvbSkpIHtcbiAgICAgIGZyb20gPSAtMVxuICAgIH1cbiAgICByZXR1cm4gcy5zcGxpY2UoZnJvbSwgaG93bWFueSwgdHlwZSlcbiAgfSxcbiAgLyoqXG4gICAqIFNoaWZ0IHZhbHVlc1xuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtob3dtYW55PTFdIC0gTnVtYmVyIG9mIHZhbHVlIHRvIGdldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIFR5cGUgcmVzdHJpY3Rpb24uIENvdWxkIGJlIGEgbmFtZSBvZiB0eXBlIG9yIGEgY29uc3RydWN0b3IuXG4gICAqIEByZXR1cm5zIHsqfSAtIFZhbHVlLiBBcnJheSBpZiBtdWx0aXBsZSBoaXRzLlxuICAgKiBAZXhhbXBsZVxuICAgKiAgZnVuY3Rpb24gZG9Tb21ldGhpbmcoKSB7XG4gICAgICogICAgICBsZXQgYXJncyA9IGFyZ3goYXJndW1lbnRzKVxuICAgICAqICAgICAgYXJncy5zaGlmdCgpXG4gICAgICogICAgICBhcmdzLnNoaWZ0KDIpXG4gICAgICogICAgICBhcmdzLnNoaWZ0KCdzdHJpbmcnKVxuICAgICAqICAgICAgYXJncy5zaGlmdChNeUN1c3RvbUVycm9yKVxuICAgICAqICB9XG4gICAqL1xuICBzaGlmdCAoaG93bWFueSwgdHlwZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzXG4gICAgcmV0dXJuIHMuc3BsaWNlKDAsIGhvd21hbnksIHR5cGUpXG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYWxsIHJlbWFpbiB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIHJlbWFpbiAoKSB7XG4gICAgY29uc3QgcyA9IHRoaXNcbiAgICBsZXQgdmFsdWVzID0gcy52YWx1ZXNcbiAgICBzLnZhbHVlcyA9IFtdXG4gICAgcmV0dXJuIHZhbHVlc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXJneFxuIl19