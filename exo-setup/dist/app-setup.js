// Generated by LiveScript 1.5.0
var async, EventEmitter, ref$, ApplicationDependency, DockerCompose, DockerSetup, fs, yaml, assign, path, ServiceSetup, AppSetup;
async = require('async');
EventEmitter = require('events').EventEmitter;
ref$ = require('../../exosphere-shared'), ApplicationDependency = ref$.ApplicationDependency, DockerCompose = ref$.DockerCompose;
DockerSetup = require('./docker-setup');
fs = require('fs-extra');
yaml = require('js-yaml');
assign = require('lodash/assign');
path = require('path');
ServiceSetup = require('./service-setup');
AppSetup = (function(superclass){
  var prototype = extend$((import$(AppSetup, superclass).displayName = 'AppSetup', AppSetup), superclass).prototype, constructor = AppSetup;
  function AppSetup(arg$){
    this.appConfig = arg$.appConfig, this.logger = arg$.logger;
    this.write = bind$(this, 'write', prototype);
    this._assignServiceDockerConfig = bind$(this, '_assignServiceDockerConfig', prototype);
    this.dockerComposeConfig = {
      version: '3',
      services: {}
    };
    this.dockerComposeLocation = path.join(process.cwd(), 'tmp', 'docker-compose.yml');
  }
  AppSetup.prototype.startSetup = function(){
    var protectionLevel, serviceRole, ref$, serviceData, this$ = this;
    this.services = [];
    for (protectionLevel in this.appConfig.services) {
      for (serviceRole in ref$ = this.appConfig.services[protectionLevel]) {
        serviceData = ref$[serviceRole];
        this.services.push({
          role: serviceRole,
          location: serviceData.location,
          dockerImage: serviceData['docker-image']
        });
      }
    }
    return this._setupServices(function(){
      return this$._getDependenciesDockerConfig(function(err){
        switch (false) {
        case !err:
          this$.write('setup failed');
          process.exit(1);
        }
        return this$._getServiceDockerConfig(function(err){
          switch (false) {
          case !err:
            this$.write('setup failed');
            process.exit(1);
          }
          this$._renderDockerCompose();
          return this$._setupDockerImages(function(exitCode){
            switch (false) {
            case !exitCode:
              this$.write('setup failed');
              process.exit(exitCode);
            }
            return this$.write('setup complete');
          });
        });
      });
    });
  };
  AppSetup.prototype._setupServices = function(done){
    var setups, res$, i$, ref$, len$, service, x$, this$ = this;
    res$ = [];
    for (i$ = 0, len$ = (ref$ = this.services).length; i$ < len$; ++i$) {
      service = ref$[i$];
      if (service.location) {
        x$ = new ServiceSetup({
          role: service.role,
          logger: this.logger,
          config: {
            root: path.join(process.cwd(), service.location)
          }
        });
        x$.on('output', fn$);
        res$.push(x$);
      }
    }
    setups = res$;
    return async.mapSeries(setups, function(){
      return arguments[0].start(arguments[1]);
    }, function(err){
      switch (false) {
      case !err:
        throw new Error(err);
      }
      return done();
    });
    function fn$(data){
      return this$.emit('output', data);
    }
  };
  AppSetup.prototype._getDependenciesDockerConfig = function(done){
    var dependencies, i$, ref$, len$, dependencyConfig;
    dependencies = [];
    for (i$ = 0, len$ = (ref$ = this.appConfig.dependencies).length; i$ < len$; ++i$) {
      dependencyConfig = ref$[i$];
      dependencies.push(ApplicationDependency.build(dependencyConfig));
    }
    return async.mapSeries(dependencies, this._getDependenciesHelper.bind(this), function(err){
      switch (false) {
      case !err:
        throw new Error(err);
      }
      return done();
    });
  };
  AppSetup.prototype._getDependenciesHelper = function(dependency, done){
    var this$ = this;
    return dependency.getDockerConfig(this.appConfig, function(err, dockerConfig){
      switch (false) {
      case !err:
        done(err);
      }
      assign(this$.dockerComposeConfig.services, dockerConfig);
      return done();
    });
  };
  AppSetup.prototype._getServiceDockerConfig = function(done){
    var this$ = this;
    return async.mapSeries(this.services, this._assignServiceDockerConfig, function(err){
      switch (false) {
      case !err:
        done(err);
      }
      return done();
    });
  };
  AppSetup.prototype._assignServiceDockerConfig = function(service, done){
    var dockerSetup, this$ = this;
    dockerSetup = new DockerSetup({
      appConfig: this.appConfig,
      role: service.role,
      logger: this.logger,
      serviceLocation: service.location,
      dockerImage: service.dockerImage
    });
    return dockerSetup.getServiceDockerConfig(function(err, dockerConfig){
      switch (false) {
      case !err:
        done(err);
      }
      assign(this$.dockerComposeConfig.services, dockerConfig);
      return done();
    });
  };
  AppSetup.prototype._renderDockerCompose = function(){
    fs.ensureFileSync(this.dockerComposeLocation);
    return fs.writeFileSync(this.dockerComposeLocation, yaml.safeDump(this.dockerComposeConfig));
  };
  AppSetup.prototype._setupDockerImages = function(done){
    var this$ = this;
    return DockerCompose.pullAllImages({
      write: this.write,
      cwd: path.dirname(this.dockerComposeLocation)
    }, function(exitCode, killed){
      switch (false) {
      case !exitCode:
        this$.write('Docker setup failed');
        return done(exitCode);
      default:
        return DockerCompose.buildAllImages({
          write: this$.write,
          cwd: path.dirname(this$.dockerComposeLocation)
        }, function(exitCode, killed){
          switch (false) {
          case !exitCode:
            this$.write('Docker setup failed');
            return done(exitCode);
          default:
            this$.write('Docker setup finished');
            return done();
          }
        });
      }
    });
  };
  AppSetup.prototype.write = function(text){
    return this.logger.log({
      role: 'exo-setup',
      text: text,
      trim: true
    });
  };
  return AppSetup;
}(EventEmitter));
module.exports = AppSetup;
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}