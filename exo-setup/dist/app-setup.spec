// Generated by LiveScript 1.5.0
var runProcess, expect, fs, yaml, mkdirp, path, each, rimraf, checkoutSetupApp;
runProcess = require('../../exosphere-shared').runProcess;
expect = require('chai').expect;
fs = require('fs-extra');
yaml = require('js-yaml');
mkdirp = require('mkdirp');
path = require('path');
each = require('prelude-ls').each;
rimraf = require('rimraf');
describe('AppSetup', function(){
  return describe('set up a complex app', function(){
    var this$ = this;
    this.timeout(600000);
    before(function(done){
      var x$;
      this$.appName = 'complex-setup-app';
      this$.appDir = path.join(process.cwd(), 'tmp', this$.appName);
      this$.dockerComposeLocation = path.join(this$.appDir, 'tmp', 'docker-compose.yml');
      this$.exocomName = 'exocom0.22.1';
      this$.internalServices = ['html-server', 'todo-service', 'users-service'];
      this$.internalDependencies = [this$.exocomName];
      this$.externalServices = ['external-service'];
      this$.externalDependencies = ['mongo3.4.0'];
      x$ = this$.process = checkoutSetupApp(this$.appName, this$.appDir);
      x$.on('ended', done);
      return x$;
    });
    specify('should create docker-compose.yml at the expected location', function(){
      return fs.stat(this$.dockerComposeLocation, function(err, stat){
        expect(err).to.be['null'];
        return this$.dockerCompose = yaml.safeLoad(fs.readFileSync(this$.dockerComposeLocation, 'utf8'));
      });
    });
    specify('should list all services and dependencies under \'services\'', function(){
      var allServices;
      allServices = this$.internalDependencies.concat(this$.internalServices, this$.externalDependencies, this$.externalServices);
      return expect(Object.keys(this$.dockerCompose.services)).to.have.members(allServices);
    });
    specify('should generate an image name for each dependency and external service', function(){
      this$.internalDependencies.forEach(function(dependency){
        return expect(this$.dockerCompose.services[dependency].image).to.not.be.empty;
      });
      this$.externalDependencies.forEach(function(dependency){
        return expect(this$.dockerCompose.services[dependency].image).to.not.be.empty;
      });
      return this$.externalServices.forEach(function(service){
        return expect(this$.dockerCompose.services[service].image).to.not.be.empty;
      });
    });
    specify('should generate a container name for each service and dependency', function(){
      this$.internalServices.forEach(function(service){
        return expect(this$.dockerCompose.services[service].container_name).to.not.be.empty;
      });
      this$.externalServices.forEach(function(service){
        return expect(this$.dockerCompose.services[service].container_name).to.not.be.empty;
      });
      this$.internalDependencies.forEach(function(dependency){
        return expect(this$.dockerCompose.services[dependency].container_name).to.not.be.empty;
      });
      return this$.externalDependencies.forEach(function(dependency){
        return expect(this$.dockerCompose.services[dependency].container_name).to.not.be.empty;
      });
    });
    specify('should have the correct build command for each service and dependency', function(){
      this$.internalServices.forEach(function(service){
        return expect(this$.dockerCompose.services[service].command).to.eql('echo "does not run"');
      });
      return this$.internalDependencies.forEach(function(dependency){
        return expect(this$.dockerCompose.services[dependency].command).to.eql(("bin/" + dependency).replace(/(\d+\.)?(\d+\.)?(\*|\d+)$/, ''));
      });
    });
    specify('should have the correct build path for each internal service', function(){
      return this$.internalServices.forEach(function(service){
        return expect(this$.dockerCompose.services[service].build).to.eql("../" + service);
      });
    });
    specify('should include \'exocom\' in the dependencies of every service', function(){
      return this$.internalServices.concat(this$.externalServices.forEach(function(service){
        return expect(this$.dockerCompose.services[service].depends_on).to.include(this$.exocomName);
      }));
    });
    specify('should include external dependencies as dependencies', function(){
      return expect(this$.dockerCompose.services['todo-service'].depends_on).to.include('mongo3.4.0');
    });
    specify('should set up an \'environment\' for exocom with a port and correct service routes', function(){
      var exocomEnv;
      exocomEnv = this$.dockerCompose.services[this$.exocomName].environment;
      expect(exocomEnv.ROLE).to.eql('exocom');
      expect(exocomEnv.PORT).to.eql('$EXOCOM_PORT');
      return expect(exocomEnv.SERVICE_ROUTES).to.eql('[{"role":"html-server","receives":["todo.created"],"sends":["todo.create"]},{"role":"todo-service","receives":["todo.create"],"sends":["todo.created"]},{"role":"users-service","receives":["mongo.list","mongo.create"],"sends":["mongo.listed","mongo.created"],"namespace":"mongo"},{"role":"external-service","receives":["users.listed","users.created"],"sends":["users.list","users.create"]}]');
    });
    specify('should set up an \'environment\' for internal service with exocom as host', function(){
      return this$.internalServices.forEach(function(service){
        var env;
        env = this$.dockerCompose.services[service].environment;
        expect(env.ROLE).to.eql(service);
        expect(env.EXOCOM_HOST).to.eql(this$.exocomName);
        return expect(env.EXOCOM_PORT).to.eql('$EXOCOM_PORT');
      });
    });
    specify('should generate a volume path for an external dependency that mounts a volume', function(){
      return expect(this$.dockerCompose.services['mongo3.4.0'].volumes).to.not.be.empty;
    });
    specify('should have the specified image and container names for the external service', function(){
      var serviceName, imageName;
      serviceName = 'external-service';
      imageName = 'originate/test-web-server';
      expect(this$.dockerCompose.services[serviceName].image).to.eql(imageName);
      return expect(this$.dockerCompose.services[serviceName].container_name).to.eql(serviceName);
    });
    specify('should have the specified ports, volumes and environment variables for the external service', function(){
      var serviceName, ports, environmentVariables;
      serviceName = 'external-service';
      ports = ['5000:5000'];
      environmentVariables = {
        'EXTERNAL_SERVICE_HOST': 'external-service0.1.2',
        'EXTERNAL_SERVICE_PORT': '$EXTERNAL_SERVICE_PORT'
      };
      expect(this$.dockerCompose.services[serviceName].ports).to.eql(ports);
      expect(this$.dockerCompose.services[serviceName].volumes).to.not.be.empty;
      return expect(this$.dockerCompose.services[serviceName].environment).to.include(environmentVariables);
    });
    return specify('should have the ports and volumes for the external dependency defined in application.yml', function(){
      var serviceName, ports;
      serviceName = 'mongo3.4.0';
      ports = ['4000:4000'];
      expect(this$.dockerCompose.services[serviceName].ports).to.eql(ports);
      return expect(this$.dockerCompose.services[serviceName].volumes).to.not.be.empty;
    });
  });
});
checkoutSetupApp = function(appName, appDir){
  rimraf.sync(appDir);
  mkdirp.sync(appDir);
  fs.copySync(path.join(process.cwd(), '..', 'exosphere-shared', 'example-apps', appName), appDir);
  return runProcess(path.join(process.cwd(), 'bin', 'exo-setup'), appDir);
};