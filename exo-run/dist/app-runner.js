// Generated by LiveScript 1.5.0
var async, Asynchronizer, red, EventEmitter, ref$, ApplicationDependency, DockerCompose, DockerHelper, fs, path, ServiceRestarter, yaml, AppRunner;
async = require('async');
Asynchronizer = require('asynchronizer');
red = require('chalk').red;
EventEmitter = require('events').EventEmitter;
ref$ = require('../../exosphere-shared'), ApplicationDependency = ref$.ApplicationDependency, DockerCompose = ref$.DockerCompose, DockerHelper = ref$.DockerHelper;
fs = require('fs');
path = require('path');
ServiceRestarter = require('./service-restarter');
yaml = require('js-yaml');
AppRunner = (function(superclass){
  var prototype = extend$((import$(AppRunner, superclass).displayName = 'AppRunner', AppRunner), superclass).prototype, constructor = AppRunner;
  function AppRunner(arg$){
    var i$, ref$, len$, dependencyConfig, dependency, ref1$;
    this.appConfig = arg$.appConfig, this.logger = arg$.logger;
    this.write = bind$(this, 'write', prototype);
    this._getOnlineText = bind$(this, '_getOnlineText', prototype);
    this._compileOnlineText = bind$(this, '_compileOnlineText', prototype);
    this.shutdown = bind$(this, 'shutdown', prototype);
    this.env = {};
    for (i$ = 0, len$ = (ref$ = this.appConfig.dependencies).length; i$ < len$; ++i$) {
      dependencyConfig = ref$[i$];
      dependency = ApplicationDependency.build(dependencyConfig);
      this.env = (ref1$ = {}, import$(ref1$, this.env), import$(ref1$, dependency.getEnvVariables()));
    }
    this.dockerConfigLocation = path.join(process.cwd(), 'tmp');
  }
  AppRunner.prototype.start = function(){
    var this$ = this;
    this.watchServices();
    this.process = DockerCompose.runAllImages({
      env: this.env,
      cwd: this.dockerConfigLocation,
      write: this.write
    }, function(exitCode){
      switch (false) {
      case !exitCode:
        return this$.shutdown({
          errorMessage: 'Failed to run images'
        });
      }
    });
    return this._compileOnlineText(function(err){
      var asynchronizer, role, ref$, onlineText;
      switch (false) {
      case !err:
        throw err;
      }
      asynchronizer = new Asynchronizer(Object.keys(this$.onlineTexts));
      for (role in ref$ = this$.onlineTexts) {
        onlineText = ref$[role];
        (fn$.call(this$, role, onlineText));
      }
      return asynchronizer.then(function(){
        return this$.write('all services online');
      });
      function fn$(role, onlineText){
        var this$ = this;
        this.process.wait(new RegExp(role + ".*" + onlineText), function(){
          this$.logger.log({
            role: role,
            text: "'" + role + "' is running"
          });
          return asynchronizer.check(role);
        });
      }
    });
  };
  AppRunner.prototype.watchServices = function(){
    var protectionLevel, lresult$, role, ref$, serviceData, x$, results$ = [], this$ = this;
    this.services = [];
    for (protectionLevel in this.appConfig.services) {
      lresult$ = [];
      for (role in ref$ = this.appConfig.services[protectionLevel]) {
        serviceData = ref$[role];
        if (serviceData.location) {
          x$ = new ServiceRestarter({
            role: role,
            serviceLocation: path.join(process.cwd(), serviceData.location),
            env: this.env,
            logger: this.logger
          });
          x$.watch();
          x$.on('error', fn$);
          lresult$.push(x$);
        }
      }
      results$.push(lresult$);
    }
    return results$;
    function fn$(message){
      return this$.shutdown({
        errorMessage: message
      });
    }
  };
  AppRunner.prototype.shutdown = function(arg$){
    var closeMessage, errorMessage, exitCode;
    closeMessage = arg$.closeMessage, errorMessage = arg$.errorMessage;
    switch (false) {
    case !errorMessage:
      console.log(red(errorMessage));
      exitCode = 1;
      break;
    default:
      console.log("\n\n " + closeMessage);
      exitCode = 0;
    }
    return DockerCompose.killAllContainers({
      cwd: this.dockerConfigLocation,
      write: this.write
    }, function(){
      return process.exit(exitCode);
    });
  };
  AppRunner.prototype._compileOnlineText = function(done){
    var i$, ref$, len$, appDependency, dependency, services, protectionLevel, role, serviceData, this$ = this;
    this.onlineTexts = {};
    for (i$ = 0, len$ = (ref$ = this.appConfig.dependencies).length; i$ < len$; ++i$) {
      appDependency = ref$[i$];
      dependency = ApplicationDependency.build(appDependency);
      this.onlineTexts[appDependency.name] = dependency.getOnlineText();
    }
    services = [];
    for (protectionLevel in this.appConfig.services) {
      for (role in ref$ = this.appConfig.services[protectionLevel]) {
        serviceData = ref$[role];
        services.push({
          role: role,
          serviceData: serviceData
        });
      }
    }
    return async.mapSeries(services, this._getOnlineText, function(err){
      switch (false) {
      case !err:
        done(err);
      }
      return done();
    });
  };
  AppRunner.prototype._getOnlineText = function(arg$, done){
    var role, serviceData, serviceConfig, this$ = this;
    role = arg$.role, serviceData = arg$.serviceData;
    switch (false) {
    case !serviceData.location:
      serviceConfig = yaml.safeLoad(fs.readFileSync(path.join(process.cwd(), serviceData.location, 'service.yml')));
      this.onlineTexts[role] = serviceConfig.startup['online-text'];
      return done();
    case !serviceData['docker-image']:
      return DockerHelper.catFile({
        image: serviceData['docker-image'],
        fileName: 'service.yml'
      }, function(err, externalServiceConfig){
        var serviceConfig;
        switch (false) {
        case !err:
          done(err);
        }
        serviceConfig = yaml.safeLoad(externalServiceConfig);
        this$.onlineTexts[role] = serviceConfig.startup['online-text'];
        return done();
      });
    default:
      return done(new Error(red("No location or docker image listed for '" + role + "'")));
    }
  };
  AppRunner.prototype.write = function(text){
    return this.logger.log({
      role: 'exo-run',
      text: text,
      trim: true
    });
  };
  return AppRunner;
}(EventEmitter));
module.exports = AppRunner;
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}