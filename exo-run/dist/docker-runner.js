// Generated by LiveScript 1.5.0
var async, red, EventEmitter, DockerHelper, fs, yaml, N, ObservableProcess, path, portReservation, last, waitUntil, DockerRunner;
async = require('async');
red = require('chalk').red;
EventEmitter = require('events').EventEmitter;
DockerHelper = require('../../exosphere-shared').DockerHelper;
fs = require('fs');
yaml = require('js-yaml');
N = require('nitroglycerin');
ObservableProcess = require('observable-process');
path = require('path');
portReservation = require('port-reservation');
last = require('prelude-ls').last;
waitUntil = require('wait').waitUntil;
DockerRunner = (function(superclass){
  var prototype = extend$((import$(DockerRunner, superclass).displayName = 'DockerRunner', DockerRunner), superclass).prototype, constructor = DockerRunner;
  function DockerRunner(arg$){
    this.role = arg$.role, this.dockerConfig = arg$.dockerConfig, this.logger = arg$.logger;
    this._checkDependencyContainers = bind$(this, '_checkDependencyContainers', prototype);
    this._runContainer = bind$(this, '_runContainer', prototype);
    this._onContainerError = bind$(this, '_onContainerError', prototype);
    this.write = bind$(this, 'write', prototype);
  }
  DockerRunner.prototype.startService = function(){
    var this$ = this;
    if (!DockerHelper.imageExists({
      author: this.dockerConfig.author,
      name: this.dockerConfig.image,
      version: this.dockerConfig.version
    })) {
      return this.emit('error', "No Docker image exists for service '" + this.role + "'. Please run exo-setup.");
    }
    DockerHelper.removeContainer(this.role);
    switch (this.role) {
    case 'exocom':
      return this._runContainer();
    default:
      return waitUntil(function(){
        return DockerHelper.getDockerIp('exocom');
      }, 10, function(){
        this$.dockerConfig.env.EXOCOM_HOST = DockerHelper.getDockerIp('exocom');
        return this$._checkDependencyContainers(function(){
          return this$._runContainer();
        });
      });
    }
  };
  DockerRunner.prototype.write = function(text){
    return this.logger.log({
      role: this.role,
      text: text,
      trim: true
    });
  };
  DockerRunner.prototype._createRunCommand = function(){
    var command, name, ref$, val, port;
    command = "docker run --name=" + this.dockerConfig.env.ROLE + " ";
    for (name in ref$ = this.dockerConfig.env) {
      val = ref$[name];
      command += " -e " + name + "=" + val;
    }
    for (name in ref$ = this.dockerConfig.publish) {
      port = ref$[name];
      command += " --publish " + port;
    }
    command += " " + this.dockerConfig.author + "/" + this.dockerConfig.image;
    if (this.dockerConfig.version) {
      command += ":" + this.dockerConfig.version;
    }
    return command += " " + this.dockerConfig.startCommand;
  };
  DockerRunner.prototype._onContainerError = function(){
    return this.emit('error', "Service '" + this.role + "' crashed, shutting down application");
  };
  DockerRunner.prototype._runContainer = function(){
    var x$, this$ = this;
    x$ = this.dockerContainer = new ObservableProcess(this._createRunCommand(), {
      stdout: {
        write: this.write
      },
      stderr: {
        write: this.write
      }
    });
    x$.on('ended', function(exitCode, killed){
      switch (false) {
      case !(exitCode > 0 && !killed):
        return this$._onContainerError();
      }
    });
    x$.wait(this.dockerConfig.startText, function(){
      this$.logger.log({
        role: 'exo-run',
        text: "'" + this$.role + "' is running"
      });
      return this$.emit('online');
    });
    return x$;
  };
  DockerRunner.prototype._checkDependencyContainers = function(done){
    var this$ = this;
    return async.mapSeries(this.dockerConfig.dependencies, DockerHelper.ensureContainerIsRunning, function(err){
      var i$, ref$, len$, dependency;
      switch (false) {
      case !err:
        this$.emit('error', err);
      }
      for (i$ = 0, len$ = (ref$ = this$.dockerConfig.dependencies).length; i$ < len$; ++i$) {
        dependency = ref$[i$];
        this$.dockerConfig.env[dependency.dependencyName.toUpperCase()] = DockerHelper.getDockerIp(dependency.containerName);
      }
      return done();
    });
  };
  return DockerRunner;
}(EventEmitter));
module.exports = DockerRunner;
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}